<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>New Troubadour Events with Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            color: #333;
            text-align: center;
            margin: 5px 0 10px 0;
        }

        h2 {
            text-align: center;
            font-style: italic;
            color: #898b89;
            margin: 5px 0 20px 0;
            font-size: 18px;
        }

        .layout-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .layout-container {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2e7d32;
            box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.3);
        }

        .date-inputs {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.3s;
        }

        #map-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            height: 600px;
        }

        #map {
            height: 100%;
            border-radius: 4px;
        }

        .events-list {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .event {
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .event:hover {
            background-color: #f0f0f0;
        }

        .event.special {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%);
            border: 2px solid #2e7d32;
            color: white;
        }

        .event.music {
            background: linear-gradient(135deg, #443cd7 0%, #8e9df3 100%);
            border: 2px solid #1006c6;
            color: white;
        }

        .event.highlighted {
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            border-left-width: 8px;
        }

        .event-name {
            font-weight: bold;
            font-size: 16px;
        }

        .event-date {
            margin-top: 5px;
        }


        .event-location {
            color: #777;
            font-style: italic;
            margin-top: 3px;
            font-size: 14px;
        }

        .special .event-location,
        .music .event-location {
            color: #c8e6c9;
        }

        .event.hidden {
            display: none;
        }

        .event-facebook {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-facebook svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook:hover svg {
            fill: #145dbf;
        }


        .event-facebook-inline {
            display: inline-flex;
            text-decoration: none !important;
            border: none !important;
            border-bottom: none !important;
            vertical-align: middle;
        }

        .event-facebook-inline svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook-inline:hover svg {
            fill: #145dbf;
        }


        /* SPECIAL event override ‚Äî white circle, blue F */
        .folk svg,
        .event-facebook-inline svg {
            fill: #ffffff;
            /* make whole shape white */
        }

        /* SPECIAL event + hover (if you want the F to stay blue on hover) */
        .folk svg,
        .event-facebook-inline:hover svg {
            fill: #ffffff;
        }

        /* Then recolor only the F using stroke */
        .folk svg path,
        .event-facebook-inline svg path {
            stroke: #1877f2;
            /* FB blue outline = F shape */
            stroke-width: 2px;
            /* adjust until the ‚ÄúF‚Äù looks right */
            stroke-linejoin: round;
        }

        .event-tickets {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .event-tickets a {
            color: #2e7d32;
            text-decoration: none;
            font-weight: bold;
            border-bottom: 2px solid #4CAF50;
        }

        .event-tickets a {
            color: #ffeb3b;
            border-bottom: 2px solid #fff59d;
        }

        .event-tickets a:hover {
            border-bottom-color: #ffffff;
        }

        .event-badge {
            background: rgba(76, 175, 80, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }


        .event-date-cancelled {
            text-decoration: line-through;
            color: #999;
        }

        .event-date-rescheduled-notice {
            color: #d32f2f;
            font-weight: bold;
        }

        .event-date-usually {
            color: #2e7d32;
            font-style: italic;
        }

        .venue-link {
            text-decoration: none;
            color: inherit;
        }

        .venue-link:hover {
            text-decoration: underline;
        }

        .search-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .event-email,
        .event-website {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-email svg,
        .event-website svg {
            width: 20px;
            height: 20px;
            transition: fill 0.3s;
        }

        .event-email svg {
            fill: #ffffff;
        }

        .event-email:hover svg {
            fill: #77ee77;
        }

        .event-website svg {
            fill: #555555;
        }

        .event-website:hover svg {
            fill: #1eb868;
        }

        /* Email icon reversed for .event.special */
        /* Normal state inside special event */
        .event.music .event-email svg {
            fill: #77ee77;
            /* inverted from white */
        }

        /* Hover state inside special event */
        .event.music .event-email:hover svg {
            fill: #ffffff;
            /* inverted from #77ee77 */
        }


        /* -------- WEBSITE -------- */

        /* Normal state inside special event */
        .event.music .event-website svg {
            fill: #1eb868;
            /* inverted from #555555 */
        }

        /* Hover state inside special event */
        .event.music .event-website:hover svg {
            fill: #555555;
            /* inverted from #1eb868 */
        }

        .event.folk {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
            border: 2px solid #654321;
            color: white;
        }

        .event.session {
            background: linear-gradient(135deg, #90ee90 0%, #98fb98 100%);
            border: 2px solid #228b22;
            color: #1a5c1a;
        }

        .folk .event-location {
            color: #f5deb3;
        }

        .session .event-location {
            color: #2d5a2d;
        }

        .event.folk .event-email svg {
            fill: #f5deb3;
        }

        .event.folk .event-email:hover svg {
            fill: #ffffff;
        }

        .event.folk .event-website svg {
            fill: #f5deb3;
        }

        .event.folk .event-website:hover svg {
            fill: #ffffff;
        }

        .event.session .event-email svg {
            fill: #228b22;
        }

        .event.session .event-email:hover svg {
            fill: #1a5c1a;
        }

        .event.session .event-website svg {
            fill: #228b22;
        }

        .event.session .event-website:hover svg {
            fill: #1a5c1a;
        }

        .search-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        #searchInput {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .no-events {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .leaflet-popup-content {
            margin: 10px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }

        .popup-content p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            button {
                padding: 8px 6px;
                font-size: 11px;
            }

            .date-inputs {
                grid-template-columns: auto 1fr;
                gap: 8px;
            }
        }

        .event-expand-btn {
            display: block;
            margin-top: 12px;
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            width: fit-content;
        }

        .event-expand-btn:hover {
            border-bottom-color: #ffffff;
        }

        .event-tickets .separator {
            color: #ffeb3b;
            margin: 0 8px;
        }

        .event.special .event-expand-btn,
        .event.music .event-expand-btn,
        .event.folk .event-expand-btn,
        .event.session .event-expand-btn {
            background: rgba(255, 255, 255, 0.3);
        }

        .event.special .event-expand-btn:hover,
        .event.music .event-expand-btn:hover,
        .event.folk .event-expand-btn:hover,
        .event.session .event-expand-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .event-expandable {
            margin-top: 10px;
            padding: 15px;
            background-color: #ffffff;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            margin-bottom: 10px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }

            to {
                opacity: 1;
                max-height: 1000px;
            }
        }

        .event-description {
            margin-bottom: 15px;
            color: #333;
            line-height: 1.6;
        }

        .event-description p {
            margin: 0 0 10px 0;
        }

        .event-flyer-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        .info-banner-tabs {
            background: white;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .info-banner-tabs-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #4CAF50 0%, #66bb6a 100%);
            color: white;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }


        .tab-content-area {
            padding: 20px;
            border: 2px solid #4CAF50;
            border-top: none;
            background-color: #f9f9f9;
            animation: slideDown 0.3s ease-out;
        }

        .tab-content-area p {
            margin: 0 0 15px 0;
            line-height: 1.6;
            color: #333;
        }

        .tab-content-area p:last-child {
            margin-bottom: 0;
        }
    </style>
</head>

<body>
    <h1>The New Troubadours ‚Äî Storytelling, Music and Punk Poet Events Calendar (UK)</h1>
    <h2>Appropriate all ages, aimed at adults.</h2>

    <div class="controls">
        <div class="button-group">
            <button id="lastWeekBtn" onclick="showWeek(-1)">Last Week</button>
            <button id="thisWeekBtn" onclick="showThisWeek()">This Week</button>
            <button id="nextWeekBtn" onclick="showWeek()">Next Week</button>
            <button id="afterThatWeekBtn" onclick="showWeek(2)">Week After</button>
            <button id="andAnotherWeekBtn" onclick="showWeek(3)">And Another</button>
        </div>
        <div class="date-inputs">
            <label>From:</label>
            <input type="date" id="startDate" onchange="handleStartDateChange()">
            <label>To:</label>
            <input type="date" id="endDate" onchange="handleEndDateChange()">
            <button id="showBtn" onclick="showDateRange()">Show Events</button>
        </div>

        <div class="search-controls">
            <div class="search-row">
                <input type="text" id="searchInput" placeholder="Search events..." onkeyup="filterEvents()">
                <button onclick="clearSearch()">Clear</button>
                <button onclick="searchAllUpcoming()" style="background-color: #2e7d32;">Search All Upcoming</button>
            </div>
            <div class="filter-row">
                <label>
                    <input type="checkbox" checked id="storyclubsOn" onchange="filterEvents()">
                    Story clubs
                </label>
                <label>
                    <input type="checkbox" checked id="specialOn" onchange="filterEvents()">
                    Story shows
                </label>
                <label>
                    <input type="checkbox" id="showFolk" onchange="filterEvents()">
                    Folk clubs
                </label>
                <label>
                    <input type="checkbox" id="showSessions" onchange="filterEvents()">
                    Irish sessions
                </label>
                <label>
                    <input type="checkbox" id="showMusic" onchange="filterEvents()">
                    Music events
                </label>
            </div>
        </div>
    </div>

    <div
        style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="pinMapView" onchange="togglePinMapView()">
            <span>Pin current map view (don't auto-zoom when changing dates)</span>
        </label>
        <div style="display: flex; gap: 10px; align-items: center;">
            <button onclick="copyShareableLink()" style="background-color: #2196F3;">
                üìã Copy Shareable Link
            </button>
            <span id="copyFeedback" style="color: #4CAF50; font-size: 14px; display: none;">‚úì Link copied!</span>
        </div>
    </div>

    <div class="layout-container">
        <div id="map-container">
            <div id="map"></div>
        </div>
        <div class="events-list" id="eventsList"></div>

    </div>

    <div class="info-banner-tabs">
        <div class="info-banner-tabs-header">
            <span class="header-label">What is/are:</span>
            <button class="header-tab-button" onclick="toggleTabContent('storytelling')">storytelling?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('circles')">story circles / clubs?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('performance')">performance
                storytelling?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('storytellingshows')">storytelling
                shows?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('folknopenmic')">folk club etiquette?</button>
        </div>

        <div class="tab-content-area" id="storytelling" style="display: none;">
            <p>For starters, <em>storytelling</em> is not (just) for children... It's an entertaining way of passing the
                time. But it's also a lot more than that: a way of sharing epic tales and passing on common sense
                smarts, explaining the landscape, recounting local legends and keeping the memory of people and place
                alive.</p>
        </div>

        <div class="tab-content-area" id="circles" style="display: none;">
            <p><em>Story circles</em> and <em>story clubs</em> are often informal gatherings of tellers and listeners
                who meet up every so often, in a casual setting, to sit around a table and share tales that last 5 to 8
                minutes. Stories are <em>told</em> rather than read, and often take the form of folk or traditional
                tales, as well as myths, legends, and lies, that have been "heard", or "found", rather than "authored",
                even though they may have been heavily worked on by the teller. By agreement, some story clubs or story
                circles may provide opportunities for longer stories to be told. Some story clubs may feature
                <em>performance storytelling</em> from local storytellers or guest storytellers, as well open
                performance storytelling floor spots.</em>
            </p>
        </div>

        <div class="tab-content-area" id="performance" style="display: none;">
            <p><em>Performance storytelling</em> moves the teller or tellers rather more to centre stage, adopting a
                more formal setting than a sharing of stories in a story circle, and with the teller clearly taking on a
                performer role. Stories often take longer in the telling than tales told in story circles, 8 to 15
                minutes or so, or even longer, up to an hour for many longer traditional tales.</p>
        </div>

        <div class="tab-content-area" id="storytellingshows" style="display: none;">
            <p>A <em>storytelling show</em> is a performance event in which one or more storytellers tell one or more
                tales in a formal or semi-formal setting. A storytelling set, or show, show often shapes several stories
                to fit an overarching narrative or theme. Not comedy, not theatre, storytelling shows take the performer
                and audience alike into an eternal moment of remembered times and places that never existed. Which is to
                say, into a time of <em>once</em>...</p>
        </div>

        <div class="tab-content-area" id="folknopenmic" style="display: none;">
            <p>For the purpose of this list, <em>folk nights</em>, <em>folk clubs</em> and <em>open mics</em> are open
                invitation events where storytellers have previously had a slot. (Folk nights as listed here often
                define "folk music" in quite broad terms..) <em>Folk nights</em> often have a one or two song policy, so
                a short 3-5 minute tale. By invitation, (particularly if you have travelled and can demonstrate a
                performance reputation elsewhere) you may be able to get a longer slot. <em>Folk clubs</em> are slightly
                more formal and more traditional in their
                repertoire. Sometimes you might get a second turn, which means you can split a longer tale at a
                cliff-hanger. <em>Open mics</em> are typically amplified events, though you can often get away with not
                using the mic. The slots may be more generous, with an up to four song policy, or a 10-12 minute tale,
                though you should probably work up to that over several sessions to build trust with the organiser and
                from the audience. To take part in any of these events, give your name to the person running the
                club/session. Contacting organisers beforehand can also put them on the look out for you.</p>
        </div>
    </div>

    <div class="about" id="colophon">
        <p><em>Hacked together by Tony Hirst in conversation with Claude.ai, inspired by <a
                    href="https://www.facebook.com/groups/societyforstorytelling/posts/10172947366465461/">a list</a> of
                storytelling club dates posted by Peter Giles to the Society for Storytelling Facebook group on
                Saturday, November 29th, 2025.</em></p>
        <p><em>For corrections, additions, removals, etc., email: <tt>montystoryteller AT gmail DOT com</tt> / web: <a
                    href="https://montystoryteller.org/"><tt>montystoryteller.org</tt></a> / fb: <a
                    href="https://www.facebook.com/montystoryteller/"><tt>montystoryteller</tt></a> / insta: <a
                    href="https://www.instagram.com/montystoryteller/"><tt>montystoryteller</tt></a>. If you're a
                regular teller at a folk night / open mic that would welcome other tellers, I can add those to the list
                too... That said, this list is opinionated. So for folk nights and open mics, I may not add the listing
                until I've visited to check that tellers are welcome.</em></p>
        <p><em>Show your appreciation by booking me for a gig, or by buying a little something for yourself: <a
                    href="https://www.amazon.co.uk/dp/B0FVYBY4V8">Island Tales</a>; <a
                    href="https://www.amazon.co.uk/dp/B0FY3TZW81">Protest Tales</a>; <a
                    href="https://www.amazon.co.uk/dp/B0FW286JLD">Dark Tales</a>.</em></p>
        <p><tt>If you're looking for a ticketing service, how about <a
                    href="https://get.tickettailor.com/z0iazwduw3fe"><strong>TicketTailor</strong> <em>[affiliate
                        link]</em></a>?</tt></p>
        <p><em><tt>This website does not collect cookies or tracking information.</tt></em></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        let map;
        let markers = [];
        let allEventsData = [];
        let isGeocoding = false;
        let eventsData = null;

        let mapViewPinned = false;
        let pinnedMapView = null;

        const UK_IRELAND_BOUNDS = L.latLngBounds(
            [49.5, -11.0],  // SW corner (Atlantic)
            [61.0, 2.5]     // NE corner (North Sea)
        );


        /**
         * Sanitize HTML to prevent XSS attacks
         * @param {string} text - The text to sanitize
         * @returns {string} - Sanitized text
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Validate and sanitize URL
         * @param {string} url - The URL to validate
         * @returns {string|null} - Sanitized URL or null if invalid
         */
        function sanitizeUrl(url) {
            if (!url) return null;

            // Remove any whitespace
            url = url.trim();

            // Only allow http, https, and mailto protocols
            const allowedProtocols = ['http:', 'https:', 'mailto:'];

            try {
                const urlObj = new URL(url, window.location.origin);

                if (!allowedProtocols.includes(urlObj.protocol)) {
                    console.warn('Blocked potentially dangerous URL:', url);
                    return null;
                }

                return urlObj.href;
            } catch (e) {
                console.warn('Invalid URL:', url);
                return null;
            }
        }

        // Load events from JSON file
        async function loadEventsData() {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`events_combined.json?v=${cacheBuster}`);
                if (response.ok) {
                    eventsData = await response.json();
                    console.log(`‚úì Loaded events from JSON:`);
                    console.log(`  - ${eventsData.events?.length || 0} recurring events`);
                    console.log(`  - ${eventsData.specificEvents?.length || 0} specific events`);
                    console.log(`  - ${eventsData.musicEvents?.length || 0} music events`);
                    console.log(`  - ${eventsData.folkNights?.length || 0} folk nights`);
                    console.log(`  - ${eventsData.irishSessions?.length || 0} Irish sessions`);

                    // Flag events with missing geocode
                    const checkMissing = (eventsList, label) => {
                        const missing = eventsList?.filter(e => e.geocode_missing) || [];
                        if (missing.length > 0) {
                            console.warn(`‚ö† ${missing.length} ${label} missing geocode data:`);
                            missing.forEach(e => console.warn(`  - ${e.name}: ${e.location}`));
                        }
                    };

                    checkMissing(eventsData.events, 'recurring events');
                    checkMissing(eventsData.specificEvents, 'specific events');
                    checkMissing(eventsData.musicEvents, 'music events');

                    return eventsData;
                } else {
                    console.error('Failed to load events_combined.json');
                    return null;
                }
            } catch (error) {
                console.error('Error loading events:', error);
                return null;
            }
        }

        function extractPostcodeArea(location) {
            if (!location) return '';
            const parts = location.split(',');
            const lastPart = parts[parts.length - 1].trim();
            const postcodeMatch = lastPart.match(/^([A-Z]+)/i);
            return postcodeMatch ? postcodeMatch[1] : '';
        }

        function initMap() {
            map = L.map('map', {
                maxBounds: UK_IRELAND_BOUNDS,
                maxBoundsViscosity: 1.0, minZoom: 5,
                maxZoom: 16
            }).setView([53.0, -2.0], 6); // Center on UK

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            map.on('moveend', updateMapView);
        }

        function parseSchedule(schedule, startDate, endDate) {
            const results = [];

            // Normalize dates to midnight for consistent comparison
            const normalizeDate = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d;
            };

            const normalizedStart = normalizeDate(startDate);
            const normalizedEnd = normalizeDate(endDate);

            // Handle specific dates (DD/MM/YYYY)
            if (schedule.includes('/')) {
                const [day, month, year] = schedule.split('/').map(num => parseInt(num, 10));
                const specificDate = normalizeDate(new Date(year, month - 1, day));
                if (specificDate >= normalizedStart && specificDate <= normalizedEnd) {
                    results.push(specificDate);
                }
                return results;
            }


            // Handle "every [dayname]" schedules
            if (schedule.toLowerCase().startsWith('every ')) {
                const dayName = schedule.toLowerCase().replace('every ', '').trim();
                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                if (targetDay === undefined) {
                    console.warn(`Invalid day name in schedule: ${schedule}`);
                    return results;
                }

                const current = new Date(normalizedStart);

                // Find the first occurrence of the target day on or after the start date
                while (current.getDay() !== targetDay) {
                    current.setDate(current.getDate() + 1);
                }

                // Add all occurrences of this day within the date range
                while (current <= normalizedEnd) {
                    const eventDate = normalizeDate(new Date(current));
                    if (eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                        results.push(eventDate);
                    }
                    current.setDate(current.getDate() + 7); // Move to next week
                }

                return results;
            }

            // Handle multiple occurrences in same month (e.g., "1st and 3rd wednesday")
            if (schedule.toLowerCase().includes(' and ')) {
                const [occurrence1Str, rest] = schedule.toLowerCase().split(' and ');
                const parts = rest.trim().split(/\s+/);
                const occurrence2Str = parts[0];
                const dayName = parts[1];

                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                const occurrenceMap = { '1st': 1, '2nd': 2, '3rd': 3, '4th': 4, 'last': 'last' };
                const occurrence1 = occurrenceMap[occurrence1Str.trim()];
                const occurrence2 = occurrenceMap[occurrence2Str.trim()];

                const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                while (current <= extendedEnd) {
                    const year = current.getFullYear();
                    const month = current.getMonth();
                    const lastDay = new Date(year, month + 1, 0);

                    // Find both occurrences
                    const occurrences = [occurrence1, occurrence2];

                    occurrences.forEach(occ => {
                        let eventDate = null;

                        if (occ === 'last') {
                            for (let d = lastDay.getDate(); d >= 1; d--) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    eventDate = testDate;
                                    break;
                                }
                            }
                        } else {
                            let count = 0;
                            for (let d = 1; d <= lastDay.getDate(); d++) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    count++;
                                    if (count === occ) {
                                        eventDate = testDate;
                                        break;
                                    }
                                }
                            }
                        }

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }
                    });

                    current.setMonth(current.getMonth() + 1);
                }

                return results.sort((a, b) => a - b);
            }

            // Handle alternating schedules (e.g., "1st wednesday (even months) | 1st thursday (odd months)")
            if (schedule.includes('|')) {
                const parts = schedule.split('|').map(s => s.trim());

                parts.forEach(part => {
                    // Extract the pattern and condition
                    const match = part.match(/^(.+?)\s*\((\w+)\s+months\)$/i);
                    if (!match) return;

                    const pattern = match[1].trim(); // e.g., "1st wednesday"
                    const condition = match[2].toLowerCase(); // "even" or "odd"

                    // Parse the base pattern
                    const [occurrence, dayName] = pattern.toLowerCase().split(/\s+/);
                    const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                    const targetDay = dayMap[dayName];

                    const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                    const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                    while (current <= extendedEnd) {
                        const year = current.getFullYear();
                        const month = current.getMonth();

                        // Check if this month matches the condition
                        const monthNumber = month + 1; // 1-12
                        const isEvenMonth = monthNumber % 2 === 0;
                        const matchesCondition = (condition === 'even' && isEvenMonth) ||
                            (condition === 'odd' && !isEvenMonth);

                        if (!matchesCondition) {
                            current.setMonth(current.getMonth() + 1);
                            continue;
                        }

                        const lastDay = new Date(year, month + 1, 0);
                        let eventDate = null;

                        if (occurrence === 'last') {
                            for (let d = lastDay.getDate(); d >= 1; d--) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    eventDate = testDate;
                                    break;
                                }
                            }
                        } else {
                            const occurrenceNum = occurrence === '1st' ? 1 :
                                occurrence === '2nd' ? 2 :
                                    occurrence === '3rd' ? 3 : 4;
                            let count = 0;
                            for (let d = 1; d <= lastDay.getDate(); d++) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    count++;
                                    if (count === occurrenceNum) {
                                        eventDate = testDate;
                                        break;
                                    }
                                }
                            }
                        }

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }

                        current.setMonth(current.getMonth() + 1);
                    }
                });

                return results.sort((a, b) => a - b);
            }

            // Handle standard recurring schedules (existing code)
            const [occurrence, dayName] = schedule.toLowerCase().split(/\s+/);
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const targetDay = dayMap[dayName];

            const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
            const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

            while (current <= extendedEnd) {
                const year = current.getFullYear();
                const month = current.getMonth();
                const lastDay = new Date(year, month + 1, 0);

                let eventDate = null;

                if (occurrence === 'last') {
                    for (let d = lastDay.getDate(); d >= 1; d--) {
                        const testDate = normalizeDate(new Date(year, month, d));
                        if (testDate.getDay() === targetDay) {
                            eventDate = testDate;
                            break;
                        }
                    }
                } else {
                    const occurrenceNum = occurrence === '1st' ? 1 : occurrence === '2nd' ? 2 : occurrence === '3rd' ? 3 : 4;
                    let count = 0;
                    for (let d = 1; d <= lastDay.getDate(); d++) {
                        const testDate = normalizeDate(new Date(year, month, d));
                        if (testDate.getDay() === targetDay) {
                            count++;
                            if (count === occurrenceNum) {
                                eventDate = testDate;
                                break;
                            }
                        }
                    }
                }

                if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                    results.push(eventDate);
                }

                current.setMonth(current.getMonth() + 1);
            }

            return results;
        }

        function getMonthParity(date) {
            return ((date.getMonth() + 1) % 2 === 0) ? 'even' : 'odd';
        }

        function resolveEventVenue(event, date) {
            const parity = getMonthParity(date);

            let location = event.location;
            let latlon = event.latlon || null;
            let venue_url = event.venue_url || null;

            if (event.alternate_locations?.[parity]) {
                const alt = event.alternate_locations[parity];
                location = alt.location || location;
                latlon = alt.latlon || latlon;
                venue_url = alt.venue_url || venue_url;
            }

            return { location, latlon, venue_url };
        }

        function parseExceptionDate(str) {
            let [d, m, y] = str.split('/').map(Number);

            // normalize year (assume 00‚Äì99 means 2000‚Äì2099)
            if (y < 100) y += 2000;

            // JS months are 0-based
            return new Date(y, m - 1, d);
        }

        function evaluateReschedule(startDate, endDate, date, exceptions) {
            const exceptionDate = exceptions.length
                ? parseExceptionDate(exceptions[0])
                : null;

            const scheduledInRange = date >= startDate && date <= endDate;
            const exceptionInRange =
                exceptionDate &&
                exceptionDate >= startDate &&
                exceptionDate <= endDate;


            const rescheduledTo =
                exceptionDate && (scheduledInRange || exceptionInRange)
                    ? exceptionDate
                    : null;

            return {
                isCancelled: Boolean(exceptionDate && scheduledInRange),
                isRescheduled: Boolean(exceptionInRange),
                rescheduledTo: rescheduledTo,
                rescheduledToStr: rescheduledTo
                    ? rescheduledTo.toLocaleDateString('en-GB', {
                        weekday: 'short',
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric'
                    })
                    : null
            };
        }

        function createSafePopup(eventData) {
            const container = document.createElement('div');
            container.className = 'popup-content';

            const h3 = document.createElement('h3');
            h3.textContent = eventData.name;
            container.appendChild(h3);

            const dateP = document.createElement('p');
            const dateStrong = document.createElement('strong');
            dateStrong.textContent = formatDate(eventData.date);
            dateP.appendChild(dateStrong);
            container.appendChild(dateP);

            const locationP = document.createElement('p');
            locationP.textContent = eventData.location;
            container.appendChild(locationP);

            if (eventData.performer) {
                const performerP = document.createElement('p');
                const performerEm = document.createElement('em');
                performerEm.textContent = eventData.performer;
                performerP.appendChild(performerEm);
                container.appendChild(performerP);
            }

            return container;
        }

        function createEventData(baseEvent, date, eventType) {
                const { location, latlon, venue_url } = resolveEventVenue(baseEvent, date);

                const eventData = {
                    name: baseEvent.name,
                    date: date,
                    time: baseEvent.time || null,
                    location: location,
                    latlon: latlon,
                    venue_url: venue_url,
                    price: baseEvent.price || null,
                    isStoryclub: eventType === 'storyclub',
                    isSpecial: eventType === 'special',
                    isMusic: eventType === 'music',
                    isFolk: eventType === 'folk',
                    isSession: eventType === 'session'
                };

                // Add type-specific fields
                if (eventType === 'storyclub' || eventType === 'folk' || eventType === 'session') {
                    eventData.club = baseEvent.club;
                    eventData.facebook = baseEvent.facebook || null;
                    eventData.email = baseEvent.email || null;
                    eventData.link = baseEvent.link || null;
                    eventData.schedule = baseEvent.schedule || null;
                    eventData.alternate_locations = baseEvent.alternate_locations || null;
                    eventData.exceptions = baseEvent.exceptions || null;

                    if (eventType === 'folk') {
                        eventData.storiesWelcome = baseEvent.storiesWelcome || false;
                        eventData.byInvitation = baseEvent.byInvitation || null;
                    }
                }

                if (eventType === 'special' || eventType === 'music') {
                    eventData.performer = baseEvent.performer;
                    eventData.performer_url = baseEvent.performer_url || null;
                    eventData.description = baseEvent.description || null;
                    eventData.event_flyer = baseEvent.event_flyer || null;
                    eventData.fb_event = baseEvent.fb_event || null;
                    eventData.ticket_url = baseEvent.ticket_url || null;
                }

                return eventData;
            }

        async function displayEvents(startDate, endDate) {
            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const eventsList = document.getElementById('eventsList');

            allEventsData = [];

            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // Process recurring events
            for (const event of eventsData.events || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                    const eventData = createEventData(event, date, 'storyclub');

                    const reschedule = evaluateReschedule(
                        startDate,
                        endDate,
                        date,
                        exceptions
                    );

                    // If there's an exception in this month, this regular date is cancelled
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(
                        startDate,
                        endDate,
                        date,
                        exceptions
                    );

                    if (reschedule.isRescheduled) {
                        const eventData = createEventData(event, reschedule.rescheduledTo, 'storyclub');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }

                }
            }

            // Process specific events
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) {
                    console.warn('Specific event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = createEventData(event, eventDate, 'special');
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process music events
            for (const event of eventsData.musicEvents || []) {
                if (!event.date) {
                    console.warn('Music event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for music event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = createEventData(event, eventDate, 'music');
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process folk nights (recurring, like story clubs)
            for (const event of eventsData.folkNights || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                    const eventData = createEventData(event, date, 'folk');

                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }

                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);

                    if (reschedule.isRescheduled) {
                        const eventData = createEventData(event, reschedule.rescheduledTo, 'folk');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Process Irish sessions (recurring, like story clubs)
            for (const event of eventsData.irishSessions || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                   const eventData = createEventData(event, date, 'session');

                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }

                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);

                    if (reschedule.isRescheduled) {
                        const eventData = createEventData(event, reschedule.rescheduledTo, 'session');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);

            renderEventsList(allEventsData);
            // Zoom map to fit all events
            fitMapToEvents();
        }

        function togglePinMapView() {
            mapViewPinned = document.getElementById('pinMapView').checked;

            if (mapViewPinned) {
                // Save current map view
                pinnedMapView = {
                    center: map.getCenter(),
                    zoom: map.getZoom()
                };
                console.log('Map view pinned:', pinnedMapView);
            } else {
                pinnedMapView = null;
                console.log('Map view unpinned - fitting to current events');
                // When unpinning, immediately fit to current events
                fitMapToEvents();
            }
        }

        function fitMapToEvents() {
            // If map view is pinned, don't auto-zoom
            if (mapViewPinned && pinnedMapView) {
                map.setView(pinnedMapView.center, pinnedMapView.zoom);
                return;
            }

            // Get all events with valid coordinates
            const eventsWithCoords = allEventsData.filter(event => event.coords);

            if (eventsWithCoords.length === 0) {
                // No events with coordinates, zoom to UK
                map.setView([53.0, -2.0], 6);
                return;
            }

            if (eventsWithCoords.length === 1) {
                // Only one event, zoom to it
                const event = eventsWithCoords[0];
                map.setView([event.coords.lat, event.coords.lon], 12);
                return;
            }

            // Multiple events - fit bounds to show all
            const bounds = L.latLngBounds(
                eventsWithCoords.map(event => [event.coords.lat, event.coords.lon])
            );
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        // Color coding: grey for story clubs, green for special events, blue for music
        const EVENT_COLORS = {
            session: '#90ee90',
            folk: '#8b4513',
            music: '#443cd7',
            special: '#4CAF50',
            storyclub: '#808080',
            default: '#808080'
        };

        const EVENT_MARKER_CONFIG = {
            session: { radius: 8, fillOpacity: 0.8 },
            folk: { radius: 8, fillOpacity: 0.8 },
            music: { radius: 8, fillOpacity: 0.8 },
            special: { radius: 8, fillOpacity: 0.8 },
            storyclub: { radius: 8, fillOpacity: 0.7 },
            default: { radius: 5, fillOpacity: 0.8 }
        };

        // Helper function to get event type
        function getEventType(eventData) {
            if (eventData.isSession) return 'session';
            if (eventData.isFolk) return 'folk';
            if (eventData.isMusic) return 'music';
            if (eventData.isSpecial) return 'special';
            if (eventData.isStoryclub) return 'storyclub';
            return 'default';
        }

        async function addMarkerForEvent(eventData) {
            // Check if latlon is provided directly
            let coords;

            // Accept [lat, lon]
            if (Array.isArray(eventData.latlon) && eventData.latlon.length === 2) {
                coords = {
                    lat: eventData.latlon[0],
                    lon: eventData.latlon[1]
                };
            }

            // Accept { lat, lon }
            else if (
                eventData.latlon &&
                typeof eventData.latlon === 'object' &&
                'lat' in eventData.latlon &&
                'lon' in eventData.latlon
            ) {
                coords = {
                    lat: eventData.latlon.lat,
                    lon: eventData.latlon.lon
                };
            }

            else {
                console.warn(`No usable coordinates for event: ${eventData.name} at ${eventData.location}`);
                return;
            }

            if (coords) {
                eventData.coords = coords;

                const eventType = getEventType(eventData);
                const markerColor = EVENT_COLORS[eventType];
                const markerConfig = EVENT_MARKER_CONFIG[eventType];

                const marker = L.circleMarker([coords.lat, coords.lon], {
                    radius: markerConfig.radius,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: markerConfig.fillOpacity
                }).addTo(map);

                marker.bindPopup(createSafePopup(eventData));
                marker.eventData = eventData;

                marker.on('click', () => {
                    highlightEvent(eventData);
                });

                markers.push(marker);
            }
        }

        function updateMapView() {
            // Filter events by map bounds
            const bounds = map.getBounds();
            const visibleEvents = allEventsData.filter(event => {
                // Always show events with "Various" location and no coords
                if (!event.coords && event.location && event.location.startsWith('Various')) {
                    return true;
                }
                if (!event.coords) return false;
                return bounds.contains([event.coords.lat, event.coords.lon]);
            });

            console.log(`Events in map view: ${visibleEvents.length} of ${allEventsData.length}`);
            renderEventsList(visibleEvents);
        }

        function toggleEventExpandable(eventId, event) {
            event.stopPropagation(); // Prevent map zoom when clicking the button
            const expandable = document.getElementById(eventId);
            if (expandable) {
                if (expandable.style.display === 'none') {
                    expandable.style.display = 'block';
                } else {
                    expandable.style.display = 'none';
                }
            }
        }


        function renderEventsList(eventsToShow) {
            const eventsList = document.getElementById('eventsList');
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            if (eventsToShow.length === 0) {
                eventsList.innerHTML = '<div class="no-events">No events in this view</div>';
                return;
            }

            console.log(`Rendering ${eventsToShow.length} events`);

            // Clear existing content
            eventsList.innerHTML = '';

            eventsToShow.forEach(event => {
                // Create event container
                const eventDiv = document.createElement('div');
                eventDiv.className = 'event';

                // Add type classes
                if (event.isStoryclub) eventDiv.classList.add('storyclub');
                if (event.isSpecial) eventDiv.classList.add('special');
                if (event.isMusic) eventDiv.classList.add('music');
                if (event.isFolk) eventDiv.classList.add('folk');
                if (event.isSession) eventDiv.classList.add('session');

                // Add click handler
                if (event.coords?.lat && event.coords?.lon) {
                    eventDiv.onclick = () => zoomToEvent(event.coords.lat, event.coords.lon);
                }

                // Set data attribute
                eventDiv.setAttribute('data-event-id', `${escapeHtml(event.name)}-${event.date.getTime()}`);

                // Build event name section with icons
                const eventNameDiv = document.createElement('div');
                eventNameDiv.className = 'event-name';

                // Add event name (SANITIZED)
                const nameText = document.createTextNode(event.name);
                eventNameDiv.appendChild(nameText);

                // Add badges if applicable
                if (event.isFolk && event.storiesWelcome) {
                    const badge = document.createElement('span');
                    badge.className = 'event-badge';
                    badge.textContent = 'üìñ Stories Welcome';
                    eventNameDiv.appendChild(document.createTextNode(' '));
                    eventNameDiv.appendChild(badge);
                }

                if (event.isFolk && event.byInvitation) {
                    const badge = document.createElement('span');
                    badge.className = 'event-badge';
                    badge.textContent = 'By Invitation';
                    eventNameDiv.appendChild(document.createTextNode(' '));
                    eventNameDiv.appendChild(badge);
                }

                // Add icons (website, email, facebook) - SANITIZED URLS
                const iconsContainer = document.createElement('span');

                // Website icon
                if (event.link) {
                    const safeUrl = sanitizeUrl(event.link);
                    if (safeUrl) {
                        const link = document.createElement('a');
                        link.href = safeUrl;
                        link.target = '_blank';
                        link.className = 'event-website';
                        link.title = 'Website';
                        link.onclick = (e) => e.stopPropagation();
                        link.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>';
                        iconsContainer.appendChild(link);
                    }
                }

                // Email icon
                if (event.email) {
                    const safeEmail = sanitizeUrl(`mailto:${event.email}`);
                    if (safeEmail) {
                        const link = document.createElement('a');
                        link.href = safeEmail;
                        link.className = 'event-email';
                        link.title = 'Email';
                        link.onclick = (e) => e.stopPropagation();
                        link.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>';
                        iconsContainer.appendChild(link);
                    }
                }

                // Facebook icon
                if (event.facebook) {
                    const fbUrl = event.facebook.startsWith('http')
                        ? event.facebook
                        : `https://facebook.com/${event.facebook}`;
                    const safeFbUrl = sanitizeUrl(fbUrl);

                    if (safeFbUrl) {
                        const link = document.createElement('a');
                        link.href = safeFbUrl;
                        link.target = '_blank';
                        link.className = 'event-facebook';
                        link.title = 'Facebook';
                        link.onclick = (e) => e.stopPropagation();
                        link.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>';
                        iconsContainer.appendChild(link);
                    }
                }

                eventNameDiv.appendChild(iconsContainer);
                eventDiv.appendChild(eventNameDiv);

                // Add performer if present (SANITIZED)
                if (event.performer) {
                    const performerDiv = document.createElement('div');
                    performerDiv.style.fontStyle = 'italic';
                    if (event.performer_url) {
                        const safePerformerUrl = sanitizeUrl(event.performer_url);
                        if (safePerformerUrl) {
                            const performerLink = document.createElement('a');
                            performerLink.href = safePerformerUrl;
                            performerLink.target = '_blank';
                            performerLink.style.color = 'inherit';
                            performerLink.style.textDecoration = 'none';
                            performerLink.onclick = (e) => e.stopPropagation();

                            const performerStrong = document.createElement('strong');
                            performerStrong.textContent = event.performer;
                            performerLink.appendChild(performerStrong);

                            performerDiv.appendChild(performerLink);
                        } else {
                            performerDiv.textContent = event.performer;
                        }
                    } else {
                        performerDiv.textContent = event.performer;
                    }
                    eventDiv.appendChild(performerDiv);
                }

                // Add location (SANITIZED with venue link)
                if (event.location) {
                    const locationDiv = document.createElement('div');
                    locationDiv.className = 'event-location';

                    if (event.venue_url) {
                        const safeVenueUrl = sanitizeUrl(event.venue_url);
                        if (safeVenueUrl) {
                            const commaIndex = event.location.indexOf(',');
                            const venueName = commaIndex > 0 ? event.location.substring(0, commaIndex) : event.location;
                            const restOfLocation = commaIndex > 0 ? event.location.substring(commaIndex) : '';

                            const venueLink = document.createElement('a');
                            venueLink.href = safeVenueUrl;
                            venueLink.target = '_blank';
                            venueLink.className = 'venue-link';

                            const venueStrong = document.createElement('strong');
                            venueStrong.textContent = venueName;
                            venueLink.appendChild(venueStrong);

                            locationDiv.appendChild(venueLink);
                            locationDiv.appendChild(document.createTextNode(restOfLocation));
                        } else {
                            locationDiv.textContent = event.location;
                        }
                    } else {
                        locationDiv.textContent = event.location;
                    }

                    eventDiv.appendChild(locationDiv);
                }

                // Add date information
                const dateDiv = document.createElement('div');
                dateDiv.className = 'event-date';

                const dayName = daysOfWeek[event.date.getDay()];
                const day = event.date.getDate();
                const month = months[event.date.getMonth()];
                const year = event.date.getFullYear();
                const scheduleText = event.schedule ? ` (${event.schedule})` : '';

                let dateText = `${dayName}, ${day} ${month} ${year}`;
                if (!event.isRescheduled) {
                    dateText += scheduleText;
                }

                if (event.isCancelled) {
                    const cancelledSpan = document.createElement('span');
                    cancelledSpan.className = 'event-date-cancelled';
                    cancelledSpan.textContent = `${dayName}, ${day} ${month} ${year} ${scheduleText}`;
                    dateDiv.appendChild(cancelledSpan);

                    if (event.rescheduledTo) {
                        const rescheduledSpan = document.createElement('span');
                        rescheduledSpan.className = 'event-date-rescheduled-notice';
                        rescheduledSpan.textContent = ` (Rescheduled to ${event.rescheduledToStr})`;
                        dateDiv.appendChild(rescheduledSpan);
                    }
                } else {
                    dateDiv.appendChild(document.createTextNode(dateText));

                    if (event.isRescheduled) {
                        const usuallySpan = document.createElement('span');
                        usuallySpan.className = 'event-date-usually';
                        usuallySpan.textContent = ` (usually ${event.schedule})`;
                        dateDiv.appendChild(usuallySpan);
                    }
                }

                // Add time and price
                if (event.time) {
                    dateDiv.appendChild(document.createTextNode(` ‚Ä¢ ${event.time}`));
                }
                if (event.price) {
                    dateDiv.appendChild(document.createTextNode(` ‚Ä¢ ${event.price}`));
                }

                eventDiv.appendChild(dateDiv);

                // Add tickets/event line for special/music events (SANITIZED)
                if ((event.isSpecial || event.isMusic)) {
                    const ticketsDiv = document.createElement('div');
                    ticketsDiv.className = 'event-tickets';

                    if (event.ticket_url) {
                        const safeTicketUrl = sanitizeUrl(event.ticket_url);
                        if (safeTicketUrl) {
                            const ticketLink = document.createElement('a');
                            ticketLink.href = safeTicketUrl;
                            ticketLink.target = '_blank';
                            ticketLink.textContent = 'Tickets available here';
                            ticketsDiv.appendChild(ticketLink);
                        }
                    }

                    if (event.fb_event) {
                        if (event.ticket_url) {
                            const separator = document.createElement('span');
                            separator.className = 'separator';
                            separator.textContent = '|';
                            ticketsDiv.appendChild(separator);
                        }

                        const fbEventUrl = sanitizeUrl(`https://www.facebook.com/events/${event.fb_event}`);
                        if (fbEventUrl) {
                            const fbLink = document.createElement('a');
                            fbLink.href = fbEventUrl;
                            fbLink.target = '_blank';
                            fbLink.className = 'event-facebook-inline';
                            fbLink.title = 'Facebook Event';
                            fbLink.onclick = (e) => e.stopPropagation();
                            fbLink.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>';
                            ticketsDiv.appendChild(fbLink);
                        }
                    }

                    if (ticketsDiv.children.length > 0) {
                        eventDiv.appendChild(ticketsDiv);
                    }
                }

                // Add expandable content if present (SANITIZED)
                const hasExpandableContent = (event.event_flyer && event.event_flyer.trim()) ||
                    (event.description && event.description.trim());

                if (hasExpandableContent) {
                    const expandableId = `event-expand-${Math.random().toString(36).substr(2, 9)}`;

                    const expandBtn = document.createElement('div');
                    expandBtn.className = 'event-expand-btn';
                    expandBtn.textContent = 'More info...';
                    expandBtn.onclick = (e) => {
                        e.stopPropagation();
                        const expandable = document.getElementById(expandableId);
                        if (expandable) {
                            expandable.style.display = expandable.style.display === 'none' ? 'block' : 'none';
                        }
                    };
                    eventDiv.appendChild(expandBtn);

                    // Create expandable content
                    const expandableDiv = document.createElement('div');
                    expandableDiv.className = 'event-expandable';
                    expandableDiv.id = expandableId;
                    expandableDiv.style.display = 'none';

                    if (event.description) {
                        const descDiv = document.createElement('div');
                        descDiv.className = 'event-description';

                        // SANITIZED: Split description into paragraphs
                        const paragraphs = event.description.split('\n\n\n\n');
                        paragraphs.forEach(p => {
                            if (p.trim()) {
                                const pElem = document.createElement('p');
                                pElem.textContent = p.replace(/\n\n/g, '\n');
                                descDiv.appendChild(pElem);
                            }
                        });

                        expandableDiv.appendChild(descDiv);
                    }

                    if (event.event_flyer) {
                        const img = document.createElement('img');
                        // SANITIZED: Use textContent for alt attribute
                        const altText = `${event.name} flyer`;
                        img.alt = altText;
                        // Basic path validation
                        const flyerPath = event.event_flyer.replace(/[^a-zA-Z0-9._-]/g, '');
                        img.src = `./storyclub_assets/event_flyers/${flyerPath}`;
                        img.className = 'event-flyer-image';
                        expandableDiv.appendChild(img);
                    }

                    eventDiv.appendChild(expandableDiv);
                }

                eventsList.appendChild(eventDiv);
            });

            // Apply filters after rendering
            filterEvents();
        }

        function zoomToEvent(lat, lon) {
            if (lat && lon) {
                map.setView([lat, lon], 13);
            }
        }

        function highlightEvent(eventData) {
            const eventId = `${eventData.name}-${eventData.date.getTime()}`;
            document.querySelectorAll('.event').forEach(el => el.classList.remove('highlighted'));
            const eventEl = document.querySelector(`[data-event-id="${eventId}"]`);
            if (eventEl) {
                eventEl.classList.add('highlighted');
                eventEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function formatDate(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${days[date.getDay()]}, ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function shouldShowEvent(eventData, filters) {
                const { storyclubsOn, specialOn, showMusic, showFolk, showSessions } = filters;

                if (storyclubsOn && eventData.isStoryclub) return true;
                if (specialOn && eventData.isSpecial) return true;
                if (showMusic && eventData.isMusic) return true;
                if (showFolk && eventData.isFolk) return true;
                if (showSessions && eventData.isSession) return true;

                return false;
            }

        function filterEvents() {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const filters = {
                    storyclubsOn: document.getElementById('storyclubsOn').checked,
                    specialOn: document.getElementById('specialOn').checked,
                    showMusic: document.getElementById('showMusic').checked,
                    showFolk: document.getElementById('showFolk').checked,
                    showSessions: document.getElementById('showSessions').checked
                };

                // Filter event list items
                document.querySelectorAll('.event').forEach(event => {
                    const isStoryclub = event.classList.contains('storyclub');
                    const isSpecial = event.classList.contains('special');
                    const isMusic = event.classList.contains('music');
                    const isFolk = event.classList.contains('folk');
                    const isSession = event.classList.contains('session');

                    const eventData = { isStoryclub, isSpecial, isMusic, isFolk, isSession };
                    let visible = shouldShowEvent(eventData, filters);

                    if (visible && searchTerm) {
                        visible = event.textContent.toLowerCase().includes(searchTerm);
                    }

                    event.classList.toggle('hidden', !visible);
                });

                // Filter map markers
                markers.forEach(marker => {
                    let visible = shouldShowEvent(marker.eventData, filters);

                    if (visible && searchTerm) {
                        const searchableText = `${marker.eventData.name} ${marker.eventData.location} ${marker.eventData.performer || ''}`.toLowerCase();
                        visible = searchableText.includes(searchTerm);
                    }

                    if (visible) {
                        marker.setStyle({ opacity: 1, fillOpacity: 0.8 });
                    } else {
                        marker.setStyle({ opacity: 0, fillOpacity: 0 });
                    }
                });

                const visibleCount = document.querySelectorAll('.event:not(.hidden)').length;
                console.log(`Visible events after filtering: ${visibleCount}`);
            }

        function clearSearch() {
            document.getElementById('searchInput').value = '';

            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput) {
                const startDate = new Date(startInput);
                const endDate = endInput
                    ? new Date(endInput)
                    : getWeekEnd(getWeekStart(startDate));

                // Re-run date-based display
                displayEvents(startDate, endDate);

                // Clear active week buttons (optional UX choice)
                document.querySelectorAll('.button-group button')
                    .forEach(btn => btn.classList.remove('active'));
            } else {
                // Fallback (should rarely happen)
                filterEvents();
            }
        }

        async function searchAllUpcoming() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();

            if (!searchTerm) {
                alert('Please enter a search term first');
                return;
            }

            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Search 2 years into the future
            const futureDate = new Date(today);
            futureDate.setFullYear(futureDate.getFullYear() + 2);

            // Clear the list and markers
            allEventsData = [];
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // The checkboxes will filter visibility after loading

            // Search recurring story club events (load regardless of checkbox)
            for (const event of eventsData.events || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    // Find the next occurrence of this recurring event
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        // Just show the first (next) occurrence
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = {
                            name: event.name,
                            date: nextDate,
                            time: event.time || null,
                            location: location,
                            club: event.club,
                            price: event.price || null,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            latlon: latlon,
                            venue_url: venue_url,
                            isStoryclub: true,
                            isSpecial: false,
                            isMusic: false,
                            isFolk: false,
                            isSession: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search specific events (story shows)
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const searchableText = `${event.name} ${event.location} ${event.performer || ''}`.toLowerCase();

                    if (searchableText.includes(searchTerm)) {
                        const eventData = {
                            name: event.name,
                            date: eventDate,
                            time: event.time || null,
                            location: event.location,
                            performer: event.performer,
                            performer_url: event.performer_url || null,
                            description: event.description || null,
                            event_flyer: event.event_flyer || null,
                            latlon: event.latlon || null,
                            fb_event: event.fb_event || null,
                            ticket_url: event.ticket_url || null,
                            price: event.price || null,
                            venue_url: event.venue_url || null,
                            isStoryclub: false,
                            isSpecial: true,
                            isMusic: false,
                            isFolk: false,
                            isSession: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search music events
            for (const event of eventsData.musicEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const searchableText = `${event.name} ${event.location} ${event.performer || ''}`.toLowerCase();

                    if (searchableText.includes(searchTerm)) {
                        const eventData = {
                            name: event.name,
                            date: eventDate,
                            time: event.time || null,
                            location: event.location,
                            performer: event.performer,
                            performer_url: event.performer_url || null,
                            description: event.description || null,
                            event_flyer: event.event_flyer || null,
                            fb_event: event.fb_event || null,
                            ticket_url: event.ticket_url || null,
                            price: event.price || null,
                            latlon: event.latlon || null,
                            venue_url: event.venue_url || null,
                            isStoryclub: false,
                            isSpecial: false,
                            isMusic: true,
                            isFolk: false,
                            isSession: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search folk nights
            for (const event of eventsData.folkNights || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = {
                            name: event.name,
                            date: nextDate,
                            time: event.time || null,
                            location: location,
                            club: event.club,
                            price: event.price || null,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            latlon: latlon,
                            venue_url: venue_url,
                            storiesWelcome: event.storiesWelcome || false,
                            byInvitation: event.byInvitation || null,
                            isStoryclub: false,
                            isSpecial: false,
                            isMusic: false,
                            isFolk: true,
                            isSession: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search Irish sessions
            for (const event of eventsData.irishSessions || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = {
                            name: event.name,
                            date: nextDate,
                            time: event.time || null,
                            location: location,
                            club: event.club,
                            price: event.price || null,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            latlon: latlon,
                            venue_url: venue_url,
                            isStoryclub: false,
                            isSpecial: false,
                            isMusic: false,
                            isFolk: false,
                            isSession: true
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);

            // Update the date inputs to reflect the search range
            updateDateInputs(today, futureDate);

            // Clear any active week button
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));

            renderEventsList(allEventsData);
            fitMapToEvents();

            if (allEventsData.length === 0) {
                const eventsList = document.getElementById('eventsList');
                eventsList.innerHTML = `<div class="no-events">No upcoming events found matching "${searchTerm}"</div>`;
            }
        }
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function getWeekEnd(weekStart) {
            const end = new Date(weekStart);
            end.setDate(end.getDate() + 6);
            return end;
        }

        function setActiveMode(mode) {
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            if (mode === 'thisWeek') document.getElementById('thisWeekBtn').classList.add('active');
            else if (mode === 'nextWeek1') document.getElementById('nextWeekBtn').classList.add('active');
            else if (mode === 'nextWeek2') document.getElementById('afterThatWeekBtn').classList.add('active');
            else if (mode === 'nextWeek3') document.getElementById('andAnotherWeekBtn').classList.add('active');
            else if (mode === 'lastWeek1') document.getElementById('lastWeekBtn').classList.add('active');
        }

        function updateDateInputs(startDate, endDate) {
            // Format dates as YYYY-MM-DD for the date inputs
            const formatForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            document.getElementById('startDate').value = formatForInput(startDate);
            document.getElementById('endDate').value = formatForInput(endDate);
        }

        function showThisWeek() {
            const today = new Date();
            const weekStart = getWeekStart(today);
            const weekEnd = getWeekEnd(weekStart);
            updateDateInputs(weekStart, weekEnd);
            displayEvents(weekStart, weekEnd);
            setActiveMode('thisWeek');
        }

        function showWeek(weeksAhead = 1) {
            const today = new Date();
            const thisWeekStart = getWeekStart(today);
            const targetWeekStart = new Date(thisWeekStart);
            targetWeekStart.setDate(targetWeekStart.getDate() + (7 * weeksAhead));
            const targetWeekEnd = getWeekEnd(targetWeekStart);
            updateDateInputs(targetWeekStart, targetWeekEnd);
            displayEvents(targetWeekStart, targetWeekEnd);
            setActiveMode(weeksAhead > 0 ? `nextWeek${weeksAhead}` : `lastWeek${Math.abs(weeksAhead)}`);
        }

        function showDateRange(clearActiveButton = true) {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select at least a start date');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));
            displayEvents(startDate, endDate);

            // Only clear active button styling when manually using custom date range
            if (clearActiveButton) {
                document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            }
        }
        let lastStartDate = '';
        let lastEndDate = '';

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function handleStartDateChange() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput && endInput) {
                const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
                const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

                const startDate = new Date(startYear, startMonth - 1, startDay);
                const endDate = new Date(endYear, endMonth - 1, endDay);

                // Start date changed - if it's now after end date, adjust end to end of start's week
                if (startDate > endDate) {
                    const weekEnd = getWeekEnd(getWeekStart(startDate));
                    document.getElementById('endDate').value = formatDateForInput(weekEnd);
                }
            }

            if (startInput) {
                showDateRange(true);
            }
        }

        function handleEndDateChange() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput && endInput) {
                const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
                const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

                const startDate = new Date(startYear, startMonth - 1, startDay);
                const endDate = new Date(endYear, endMonth - 1, endDay);

                // End date changed - if it's now before start date, adjust start to beginning of end's week
                if (endDate < startDate) {
                    const weekStart = getWeekStart(endDate);
                    document.getElementById('startDate').value = formatDateForInput(weekStart);
                }
            }

            if (startInput) {
                showDateRange(true);
            }
        }

        function generateShareableURL(startDate, endDate) {
            const formatForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const params = new URLSearchParams();
            params.set('start', formatForInput(startDate));
            params.set('end', formatForInput(endDate));

            // Add filter states
            params.set('storyclubs', document.getElementById('storyclubsOn').checked ? '1' : '0');
            params.set('special', document.getElementById('specialOn').checked ? '1' : '0');
            params.set('music', document.getElementById('showMusic').checked ? '1' : '0');
            params.set('folk', document.getElementById('showFolk').checked ? '1' : '0');
            params.set('sessions', document.getElementById('showSessions').checked ? '1' : '0');

            const center = map.getCenter();
            const lat = center.lat;
            const lng = center.lng;
            const zoom = map.getZoom();
            params.set('lat', lat);
            params.set('lng', lng);
            params.set('zoom', zoom);
            params.set('pinmap', document.getElementById('pinMapView').checked ? '1' : '0');

            const searchTerm = document.getElementById('searchInput').value.trim();
            if (searchTerm) {
                params.set('q', searchTerm);
            }

            return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
        }

        async function copyShareableLink() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select a date range first');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));

            const shareableURL = generateShareableURL(startDate, endDate);

            try {
                await navigator.clipboard.writeText(shareableURL);
                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const tempInput = document.createElement('input');
                tempInput.value = shareableURL;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            }
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const start = params.get('start');
            const end = params.get('end');

            if (start) {
                const storyclubs = params.get('storyclubs') === '1';
                const special = params.get('special') === '1';
                const music = params.get('music') === '1';
                const folk = params.get('folk') === '1';
                const sessions = params.get('sessions') === '1';
                const pinmap = params.get('pinmap') === '1';
                const zoom = params.get('zoom') ? parseInt(params.get('zoom'), 10) : 6;;
                const lat = params.get('lat') ? parseFloat(params.get('lat')) : 53.0;
                const lng = params.get('lng') ? parseFloat(params.get('lng')) : 0.0;
                // If none are selected, default storyclubs and special to true
                const noneSelected = !storyclubs && !special && !music && !folk && !sessions;

                const q = params.get('q');

                return {
                    startDate: new Date(start),
                    endDate: end ? new Date(end) : null,
                    storyclubs: noneSelected ? true : storyclubs,
                    special: noneSelected ? true : special,
                    folk: noneSelected ? true : folk,
                    sessions: noneSelected ? true : sessions,
                    music: music,
                    pinmap: pinmap,
                    lat: lat,
                    lng: lng,
                    zoom: zoom,
                    searchTerm: q
                };
            }
            return null;
        }


        function toggleTabContent(tabId) {
            const allTabs = document.querySelectorAll('.tab-content-area');
            const clickedTab = document.getElementById(tabId);
            const allButtons = document.querySelectorAll('.header-tab-button');

            // If clicking the already-open tab, close it
            if (clickedTab.style.display === 'block') {
                clickedTab.style.display = 'none';
                event.target.classList.remove('active');
            } else {
                // Close all tabs
                allTabs.forEach(tab => tab.style.display = 'none');
                allButtons.forEach(btn => btn.classList.remove('active'));

                // Open clicked tab
                clickedTab.style.display = 'block';
                event.target.classList.add('active');
            }
        }

        // Initialize
        window.addEventListener('load', async () => {
            await loadEventsData();
            initMap();

            // Check for URL parameters first
            const urlParams = getURLParams();
            if (urlParams) {
                const startDate = urlParams.startDate;
                const endDate = urlParams.endDate || getWeekEnd(getWeekStart(startDate));

                document.getElementById('storyclubsOn').checked = urlParams.storyclubs;
                document.getElementById('specialOn').checked = urlParams.special;
                document.getElementById('showMusic').checked = urlParams.music;
                document.getElementById('showFolk').checked = urlParams.folk;
                document.getElementById('showSessions').checked = urlParams.sessions;

                updateDateInputs(startDate, endDate);

                document.getElementById('pinMapView').checked = urlParams.pinmap;
                console.log("pinmap", urlParams, urlParams.pinmap)
                mapViewPinned = urlParams.pinmap;

                // Apply specific map view if provided
                if (urlParams.lat && urlParams.lng && urlParams.zoom) {
                    map.setView([urlParams.lat, urlParams.lng], urlParams.zoom);
                    if (mapViewPinned) {
                        pinnedMapView = {
                            center: [urlParams.lat, urlParams.lng],
                            zoom: urlParams.zoom
                        };
                    }
                }

                //  restore search term
                if (urlParams.searchTerm) {
                    document.getElementById('searchInput').value = urlParams.searchTerm;

                    // Behave exactly like "Search All Upcoming"
                    await searchAllUpcoming();
                } else {
                    await displayEvents(startDate, endDate);
                }
            } else {
                showThisWeek();
            }
        });

    </script>
</body>

</html>