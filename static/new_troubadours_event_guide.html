<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Troubadour Events with Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            color: #333;
            text-align: center;
            margin: 5px 0 10px 0;
        }

        h2 {
            text-align: center;
            font-style: italic;
            color: #898b89;
            margin: 5px 0 20px 0;
            font-size: 18px;
        }

        .layout-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .layout-container {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2e7d32;
            box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.3);
        }

        .date-inputs {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.3s;
        }

        #map-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            height: 600px;
        }

        #map {
            height: 100%;
            border-radius: 4px;
        }

        .events-list {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .event {
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .event:hover {
            background-color: #f0f0f0;
        }

        .event.special {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%);
            border: 2px solid #2e7d32;
            color: white;
        }

        .event.music {
            background: linear-gradient(135deg, #443cd7 0%, #8e9df3 100%);
            border: 2px solid #1006c6;
            color: white;
        }

        .event.highlighted {
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            border-left-width: 8px;
        }

        .event-name {
            font-weight: bold;
            font-size: 16px;
        }

        .event-date {
            margin-top: 5px;
        }


        .event-location {
            color: #777;
            font-style: italic;
            margin-top: 3px;
            font-size: 14px;
        }

        .special .event-location, .music .event-location
         {
            color: #c8e6c9;
        }
        .event.hidden {
            display: none;
        }

        .event-facebook {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-facebook svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook:hover svg {
            fill: #145dbf;
        }


        .event-facebook-inline {
            display: inline-flex;
            text-decoration: none !important;
            border: none !important;
            border-bottom: none !important;
            vertical-align: middle;
        }

        .event-facebook-inline svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook-inline:hover svg {
            fill: #145dbf;
        }


        /* SPECIAL event override ‚Äî white circle, blue F */
        .event-facebook-inline svg {
            fill: #ffffff;
            /* make whole shape white */
        }

        /* SPECIAL event + hover (if you want the F to stay blue on hover) */
        .event-facebook-inline:hover svg {
            fill: #ffffff;
        }

        /* Then recolor only the F using stroke */
        .event-facebook-inline svg path {
            stroke: #1877f2;
            /* FB blue outline = F shape */
            stroke-width: 2px;
            /* adjust until the ‚ÄúF‚Äù looks right */
            stroke-linejoin: round;
        }

        .event-tickets {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .event-tickets a {
            color: #2e7d32;
            text-decoration: none;
            font-weight: bold;
            border-bottom: 2px solid #4CAF50;
        }

        .event-tickets a {
            color: #ffeb3b;
            border-bottom: 2px solid #fff59d;
        }

        .event-tickets a:hover {
            border-bottom-color: #ffffff;
        }

        .search-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .event-email,
        .event-website {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-email svg,
        .event-website svg {
            width: 20px;
            height: 20px;
            transition: fill 0.3s;
        }

        .event-email svg {
            fill: #ffffff;
        }

        .event-email:hover svg {
            fill: #77ee77;
        }

        .event-website svg {
            fill: #555555;
        }

        .event-website:hover svg {
            fill: #1eb868;
        }

        /* Email icon reversed for .event.special */
        /* Normal state inside special event */
        .event.music .event-email svg {
            fill: #77ee77;
            /* inverted from white */
        }

        /* Hover state inside special event */
        .event.music .event-email:hover svg {
            fill: #ffffff;
            /* inverted from #77ee77 */
        }


        /* -------- WEBSITE -------- */

        /* Normal state inside special event */
        .event.music .event-website svg {
            fill: #1eb868;
            /* inverted from #555555 */
        }

        /* Hover state inside special event */
        .event.music .event-website:hover svg {
            fill: #555555;
            /* inverted from #1eb868 */
        }
        
        .event.folk {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
            border: 2px solid #654321;
            color: white;
        }

        .event.session {
            background: linear-gradient(135deg, #90ee90 0%, #98fb98 100%);
            border: 2px solid #228b22;
            color: #1a5c1a;
        }

        .folk .event-location {
            color: #f5deb3;
        }

        .session .event-location {
            color: #2d5a2d;
        }

        .event.folk .event-email svg {
            fill: #f5deb3;
        }

        .event.folk .event-email:hover svg {
            fill: #ffffff;
        }

        .event.folk .event-website svg {
            fill: #f5deb3;
        }

        .event.folk .event-website:hover svg {
            fill: #ffffff;
        }

        .event.session .event-email svg {
            fill: #228b22;
        }

        .event.session .event-email:hover svg {
            fill: #1a5c1a;
        }

        .event.session .event-website svg {
            fill: #228b22;
        }

        .event.session .event-website:hover svg {
            fill: #1a5c1a;
        }

        .search-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        #searchInput {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .no-events {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .leaflet-popup-content {
            margin: 10px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }

        .popup-content p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            button {
                padding: 8px 6px;
                font-size: 11px;
            }

            .date-inputs {
                grid-template-columns: auto 1fr;
                gap: 8px;
            }
        }

.event-expand-btn {
    display: block;
    margin-top: 12px;
    padding: 6px 12px;
    background: #4CAF50;
    color: white;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.3s;
    width: fit-content;
}

.event-expand-btn:hover {
    border-bottom-color: #ffffff;
}

.event-tickets .separator {
    color: #ffeb3b;
    margin: 0 8px;
}

.event.special .event-expand-btn,
.event.music .event-expand-btn,
.event.folk .event-expand-btn,
.event.session .event-expand-btn {
    background: rgba(255, 255, 255, 0.3);
}

.event.special .event-expand-btn:hover,
.event.music .event-expand-btn:hover,
.event.folk .event-expand-btn:hover,
.event.session .event-expand-btn:hover {
    background: rgba(255, 255, 255, 0.5);
}

.event-expandable {
    margin-top: 10px;
    padding: 15px;
    background-color: #ffffff;
    border-left: 4px solid #4CAF50;
    border-radius: 4px;
    margin-bottom: 10px;
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from {
        opacity: 0;
        max-height: 0;
    }
    to {
        opacity: 1;
        max-height: 1000px;
    }
}

.event-description {
    margin-bottom: 15px;
    color: #333;
    line-height: 1.6;
}

.event-description p {
    margin: 0 0 10px 0;
}

.event-flyer-image {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
    </style>
</head>

<body>
    <h1>The New Troubadours ‚Äî Storytelling, Music and Punk Poet Events Calendar (UK)</h1>
    <h2>Appropriate all ages, aimed at adults.</h2>

    <div class="controls">
        <div class="button-group">
            <button id="lastWeekBtn" onclick="showWeek(-1)">Last Week</button>
            <button id="thisWeekBtn" onclick="showThisWeek()">This Week</button>
            <button id="nextWeekBtn" onclick="showWeek()">Next Week</button>
            <button id="afterThatWeekBtn" onclick="showWeek(2)">Week After</button>
            <button id="andAnotherWeekBtn" onclick="showWeek(3)">And Another</button>
        </div>
        <div class="date-inputs">
            <label>From:</label>
            <input type="date" id="startDate" onchange="handleStartDateChange()">
            <label>To:</label>
            <input type="date" id="endDate" onchange="handleEndDateChange()">
            <button id="showBtn" onclick="showDateRange()">Show Events</button>
        </div>

        <div class="search-controls">
            <div class="search-row">
                <input type="text" id="searchInput" placeholder="Search events..." onkeyup="filterEvents()">
                <button onclick="clearSearch()">Clear</button>
                <button onclick="searchAllUpcoming()" style="background-color: #2e7d32;">Search All Upcoming</button>
            </div>
            <div class="filter-row">
                <label>
                    <input type="checkbox" checked id="storyclubsOn" onchange="filterEvents()">
                    Story clubs
                </label>
                <label>
                    <input type="checkbox" checked id="specialOn" onchange="filterEvents()">
                    Story shows
                </label>
                <label>
                    <input type="checkbox" checked id="showFolk" onchange="filterEvents()">
                    Folk clubs
                </label>
                <label>
                    <input type="checkbox" checked id="showSessions" onchange="filterEvents()">
                    Irish sessions
                </label>
                <label>
                    <input type="checkbox" id="showMusic" onchange="filterEvents()">
                    Music events
                </label>
            </div>
        </div>
    </div>

<div
    style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
    <label style="display: flex; align-items: center; gap: 10px;">
        <input type="checkbox" id="pinMapView" onchange="togglePinMapView()">
        <span>Pin current map view (don't auto-zoom when changing dates)</span>
    </label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <button onclick="copyShareableLink()" style="background-color: #2196F3;">
            üìã Copy Shareable Link
        </button>
        <span id="copyFeedback" style="color: #4CAF50; font-size: 14px; display: none;">‚úì Link copied!</span>
    </div>
</div>

    <div class="layout-container">
        <div id="map-container">
            <div id="map"></div>
        </div>
        <div class="events-list" id="eventsList"></div>
        
    </div>

<div class="about" id="colophon">
    <p><em>Hacked together by Tony Hirst in conversation with Claude.ai, inspired by <a
                href="https://www.facebook.com/groups/societyforstorytelling/posts/10172947366465461/">a list</a> of
            storytelling club dates posted by Peter Giles to the Society for Storytelling Facebook group on
            Saturday, November 29th, 2025.</em></p>
    <p><em>For corrections, additions, removals, etc., email: <tt>montystoryteller AT gmail DOT com</tt> / web: <a
                href="https://montystoryteller.org/"><tt>montystoryteller.org</tt></a> / fb: <a
                href="https://www.facebook.com/montystoryteller/"><tt>montystoryteller</tt></a> / insta: <a
                href="https://www.instagram.com/montystoryteller/"><tt>montystoryteller</tt></a>. If you're a
            regular teller at a folk night / open mic that would welcome other tellers, I can add those to the list
            too...</em></p>
    <p><em>Show your appreciation by booking me for a gig, or buying a little something for yourself:<a
                href="https://www.amazon.co.uk/dp/B0FVYBY4V8">Island Tales</a>; <a
                href="https://www.amazon.co.uk/dp/B0FY3TZW81">Protest Tales</a>; <a
                href="https://www.amazon.co.uk/dp/B0FW286JLD">Dark Tales</a>.</em></p>
    <p><em><tt>This website does not collect cookies or tracking information.</tt></em></p>
</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        let map;
        let markers = [];
        let allEventsData = [];
        let geocodeQueue = [];
        let isGeocoding = false;
        let eventsData = null;

        let mapViewPinned = false;
        let pinnedMapView = null;

        const UK_IRELAND_BOUNDS = L.latLngBounds(
                [49.5, -11.0],  // SW corner (Atlantic)
                [61.0, 2.5]     // NE corner (North Sea)
            );

        // Load events from JSON file
        async function loadEventsData() {
            try {
                const response = await fetch('events_combined.json');
                if (response.ok) {
                    eventsData = await response.json();
                    console.log(`‚úì Loaded events from JSON:`);
                    console.log(`  - ${eventsData.events?.length || 0} recurring events`);
                    console.log(`  - ${eventsData.specificEvents?.length || 0} specific events`);
                    console.log(`  - ${eventsData.musicEvents?.length || 0} music events`);
                    console.log(`  - ${eventsData.folkNights?.length || 0} folk nights`);
                    console.log(`  - ${eventsData.irishSessions?.length || 0} Irish sessions`);

                    // Flag events with missing geocode
                    const checkMissing = (eventsList, label) => {
                        const missing = eventsList?.filter(e => e.geocode_missing) || [];
                        if (missing.length > 0) {
                            console.warn(`‚ö† ${missing.length} ${label} missing geocode data:`);
                            missing.forEach(e => console.warn(`  - ${e.name}: ${e.location}`));
                        }
                    };

                    checkMissing(eventsData.events, 'recurring events');
                    checkMissing(eventsData.specificEvents, 'specific events');
                    checkMissing(eventsData.musicEvents, 'music events');

                    return eventsData;
                } else {
                    console.error('Failed to load events_combined.json');
                    return null;
                }
            } catch (error) {
                console.error('Error loading events:', error);
                return null;
            }
        }

        function extractPostcodeArea(location) {
                if (!location) return '';
                const parts = location.split(',');
                const lastPart = parts[parts.length - 1].trim();
                const postcodeMatch = lastPart.match(/^([A-Z]+)/i);
                return postcodeMatch ? postcodeMatch[1] : '';
            }

        function initMap() {
            map = L.map('map', {
                maxBounds: UK_IRELAND_BOUNDS,
                maxBoundsViscosity: 1.0, minZoom: 5,
                maxZoom: 16
                }).setView([53.0, -2.0], 6); // Center on UK

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            map.on('moveend', updateMapView);
        }

        // Rate-limited geocoding function (fallback only - most coords in JSON)
        async function geocodeLocation(location) {
            // This is now just a fallback for events without latlon in the JSON
            console.warn(`No latlon data for: ${location} - would need API geocoding`);
            return null;
        }

        function parseSchedule(schedule, startDate, endDate) {
            const results = [];

            // Normalize dates to midnight for consistent comparison
            const normalizeDate = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d;
            };

            const normalizedStart = normalizeDate(startDate);
            const normalizedEnd = normalizeDate(endDate);

            // Handle specific dates (DD/MM/YYYY)
            if (schedule.includes('/')) {
                const [day, month, year] = schedule.split('/').map(num => parseInt(num, 10));
                const specificDate = normalizeDate(new Date(year, month - 1, day));
                if (specificDate >= normalizedStart && specificDate <= normalizedEnd) {
                    results.push(specificDate);
                }
                return results;
            }


            // Handle "every [dayname]" schedules
            if (schedule.toLowerCase().startsWith('every ')) {
                const dayName = schedule.toLowerCase().replace('every ', '').trim();
                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                if (targetDay === undefined) {
                    console.warn(`Invalid day name in schedule: ${schedule}`);
                    return results;
                }

                const current = new Date(normalizedStart);

                // Find the first occurrence of the target day on or after the start date
                while (current.getDay() !== targetDay) {
                    current.setDate(current.getDate() + 1);
                }

                // Add all occurrences of this day within the date range
                while (current <= normalizedEnd) {
                    const eventDate = normalizeDate(new Date(current));
                    if (eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                        results.push(eventDate);
                    }
                    current.setDate(current.getDate() + 7); // Move to next week
                }

                return results;
            }

            // Handle multiple occurrences in same month (e.g., "1st and 3rd wednesday")
            if (schedule.toLowerCase().includes(' and ')) {
                const [occurrence1Str, rest] = schedule.toLowerCase().split(' and ');
                const parts = rest.trim().split(/\s+/);
                const occurrence2Str = parts[0];
                const dayName = parts[1];

                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                const occurrenceMap = { '1st': 1, '2nd': 2, '3rd': 3, '4th': 4, 'last': 'last' };
                const occurrence1 = occurrenceMap[occurrence1Str.trim()];
                const occurrence2 = occurrenceMap[occurrence2Str.trim()];

                const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                while (current <= extendedEnd) {
                    const year = current.getFullYear();
                    const month = current.getMonth();
                    const lastDay = new Date(year, month + 1, 0);

                    // Find both occurrences
                    const occurrences = [occurrence1, occurrence2];

                    occurrences.forEach(occ => {
                        let eventDate = null;

                        if (occ === 'last') {
                            for (let d = lastDay.getDate(); d >= 1; d--) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    eventDate = testDate;
                                    break;
                                }
                            }
                        } else {
                            let count = 0;
                            for (let d = 1; d <= lastDay.getDate(); d++) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    count++;
                                    if (count === occ) {
                                        eventDate = testDate;
                                        break;
                                    }
                                }
                            }
                        }

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }
                    });

                    current.setMonth(current.getMonth() + 1);
                }

                return results.sort((a, b) => a - b);
            }

            // Handle alternating schedules (e.g., "1st wednesday (even months) | 1st thursday (odd months)")
            if (schedule.includes('|')) {
                const parts = schedule.split('|').map(s => s.trim());

                parts.forEach(part => {
                    // Extract the pattern and condition
                    const match = part.match(/^(.+?)\s*\((\w+)\s+months\)$/i);
                    if (!match) return;

                    const pattern = match[1].trim(); // e.g., "1st wednesday"
                    const condition = match[2].toLowerCase(); // "even" or "odd"

                    // Parse the base pattern
                    const [occurrence, dayName] = pattern.toLowerCase().split(/\s+/);
                    const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                    const targetDay = dayMap[dayName];

                    const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                    const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                    while (current <= extendedEnd) {
                        const year = current.getFullYear();
                        const month = current.getMonth();

                        // Check if this month matches the condition
                        const monthNumber = month + 1; // 1-12
                        const isEvenMonth = monthNumber % 2 === 0;
                        const matchesCondition = (condition === 'even' && isEvenMonth) ||
                            (condition === 'odd' && !isEvenMonth);

                        if (!matchesCondition) {
                            current.setMonth(current.getMonth() + 1);
                            continue;
                        }

                        const lastDay = new Date(year, month + 1, 0);
                        let eventDate = null;

                        if (occurrence === 'last') {
                            for (let d = lastDay.getDate(); d >= 1; d--) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    eventDate = testDate;
                                    break;
                                }
                            }
                        } else {
                            const occurrenceNum = occurrence === '1st' ? 1 :
                                occurrence === '2nd' ? 2 :
                                    occurrence === '3rd' ? 3 : 4;
                            let count = 0;
                            for (let d = 1; d <= lastDay.getDate(); d++) {
                                const testDate = normalizeDate(new Date(year, month, d));
                                if (testDate.getDay() === targetDay) {
                                    count++;
                                    if (count === occurrenceNum) {
                                        eventDate = testDate;
                                        break;
                                    }
                                }
                            }
                        }

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }

                        current.setMonth(current.getMonth() + 1);
                    }
                });

                return results.sort((a, b) => a - b);
            }

            // Handle standard recurring schedules (existing code)
            const [occurrence, dayName] = schedule.toLowerCase().split(/\s+/);
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const targetDay = dayMap[dayName];

            const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
            const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

            while (current <= extendedEnd) {
                const year = current.getFullYear();
                const month = current.getMonth();
                const lastDay = new Date(year, month + 1, 0);

                let eventDate = null;

                if (occurrence === 'last') {
                    for (let d = lastDay.getDate(); d >= 1; d--) {
                        const testDate = normalizeDate(new Date(year, month, d));
                        if (testDate.getDay() === targetDay) {
                            eventDate = testDate;
                            break;
                        }
                    }
                } else {
                    const occurrenceNum = occurrence === '1st' ? 1 : occurrence === '2nd' ? 2 : occurrence === '3rd' ? 3 : 4;
                    let count = 0;
                    for (let d = 1; d <= lastDay.getDate(); d++) {
                        const testDate = normalizeDate(new Date(year, month, d));
                        if (testDate.getDay() === targetDay) {
                            count++;
                            if (count === occurrenceNum) {
                                eventDate = testDate;
                                break;
                            }
                        }
                    }
                }

                if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                    results.push(eventDate);
                }

                current.setMonth(current.getMonth() + 1);
            }

            return results;
        }

        function getMonthParity(date) {
            return ((date.getMonth() + 1) % 2 === 0) ? 'even' : 'odd';
        }

        function resolveEventVenue(event, date) {
            const parity = getMonthParity(date);

            let location = event.location;
            let latlon = event.latlon || null;
            let venue_url = event.venue_url || null;

            if (event.alternate_locations?.[parity]) {
                const alt = event.alternate_locations[parity];
                location = alt.location || location;
                latlon = alt.latlon || latlon;
                venue_url = alt.venue_url || venue_url;
            }

            return { location, latlon, venue_url };
        }

        function parseExceptionDate(str) {
            let [d, m, y] = str.split('/').map(Number);

            // normalize year (assume 00‚Äì99 means 2000‚Äì2099)
            if (y < 100) y += 2000;

            // JS months are 0-based
            return new Date(y, m - 1, d);
        }

       function evaluateReschedule(startDate, endDate, date, exceptions) {
            const exceptionDate = exceptions.length
                ? parseExceptionDate(exceptions[0])
                : null;

            const scheduledInRange = date >= startDate && date <= endDate;
            const exceptionInRange =
                exceptionDate &&
                exceptionDate >= startDate &&
                exceptionDate <= endDate;


           const rescheduledTo =
               exceptionDate && (scheduledInRange || exceptionInRange)
                   ? exceptionDate
                   : null;

            return {
                isCancelled: Boolean(exceptionDate && scheduledInRange),
                isRescheduled: Boolean(exceptionInRange),
                rescheduledTo: rescheduledTo,
                rescheduledToStr: rescheduledTo
                    ? rescheduledTo.toLocaleDateString('en-GB', {
                        weekday: 'short',
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric'
                    })
                    : null
            };
        }
        async function displayEvents(startDate, endDate) {
            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const eventsList = document.getElementById('eventsList');

            allEventsData = [];

            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // Process recurring events
            for (const event of eventsData.events || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                    const eventData = {
                        name: event.name,
                        date: date,
                        time: event.time || null,
                        club: event.club,
                        facebook: event.facebook || null,
                        email: event.email || null,
                        link: event.link || null,
                        schedule: event.schedule || null,
                        alternate_locations: event.alternate_locations || null,
                        price: event.price || null,
                        location,
                        latlon,
                        exceptions: event.exceptions || null,
                        venue_url,
                        isStoryclub: true,
                        isSpecial: false,
                        isMusic: false
                    };
                    
                    const reschedule = evaluateReschedule(
                        startDate,
                        endDate,
                        date,
                        exceptions
                    );

                    // If there's an exception in this month, this regular date is cancelled
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(
                        startDate,
                        endDate,
                        date,
                        exceptions
                    );
                    
                    if (reschedule.isRescheduled) {
                        const eventData = {
                            name: event.name,
                            date: reschedule.rescheduledTo,
                            time: event.time || null,
                            club: event.club,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            price: event.price || null,
                            location: location,
                            latlon: latlon,
                            exceptions: event.exceptions || null,
                            venue_url: venue_url,
                            isRescheduled : true,
                            rescheduledTo : reschedule.rescheduledTo,
                            rescheduledToStr: reschedule.rescheduledToStr,
                            isStoryclub: true,
                            isSpecial: false,
                            isMusic: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }

                }
            }

            // Process specific events
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) {
                    console.warn('Specific event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        time: event.time || null,
                        location: event.location,
                        performer: event.performer,
                        description: event.description || null,
                        event_flyer: event.event_flyer || null,
                        latlon: event.latlon || null,
                        fb_event: event.fb_event || null,
                        ticket_url: event.ticket_url || null,
                        price: event.price || null,
                        venue_url: event.venue_url || null,
                        isStoryclub: false,
                        isSpecial: true,  // All specificEvents are special events
                        isMusic: false
                    };
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process music events
            for (const event of eventsData.musicEvents || []) {
                if (!event.date) {
                    console.warn('Music event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for music event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        time: event.time || null,
                        location: event.location,
                        performer: event.performer,
                        description: event.description || null,
                        event_flyer: event.event_flyer || null,
                        fb_event: event.fb_event || null,
                        ticket_url: event.ticket_url || null,
                        price: event.price || null,
                        latlon: event.latlon || null,
                        venue_url: event.venue_url || null,
                        isStoryclub: false,
                        isSpecial: false,
                        isMusic: true  // All musicEvents are music
                    };
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process folk nights (recurring, like story clubs)
            for (const event of eventsData.folkNights || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                    const eventData = {
                        name: event.name,
                        date: date,
                        time: event.time || null,
                        club: event.club,
                        facebook: event.facebook || null,
                        email: event.email || null,
                        link: event.link || null,
                        schedule: event.schedule || null,
                        alternate_locations: event.alternate_locations || null,
                        price: event.price || null,
                        location,
                        latlon,
                        exceptions: event.exceptions || null,
                        venue_url,
                        storiesWelcome: event.storiesWelcome || false,
                        byInvitation: event.byInvitation || null, 
                        isStoryclub: false,
                        isSpecial: false,
                        isMusic: false,
                        isFolk: true,
                        isSession: false
                    };

                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }

                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);

                    if (reschedule.isRescheduled) {
                        const eventData = {
                            name: event.name,
                            date: reschedule.rescheduledTo,
                            time: event.time || null,
                            club: event.club,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            price: event.price || null,
                            location: location,
                            latlon: latlon,
                            exceptions: event.exceptions || null,
                            venue_url: venue_url,
                            storiesWelcome: event.storiesWelcome || false, byInvitation: event.byInvitation || null, 
                            isRescheduled: true,
                            rescheduledTo: reschedule.rescheduledTo,
                            rescheduledToStr: reschedule.rescheduledToStr,
                            isStoryclub: false,
                            isSpecial: false,
                            isMusic: false,
                            isFolk: true,
                            isSession: false
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Process Irish sessions (recurring, like story clubs)
            for (const event of eventsData.irishSessions || []) {
                const exceptions = event.exceptions || [];
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);

                    const eventData = {
                        name: event.name,
                        date: date,
                        time: event.time || null,
                        club: event.club,
                        facebook: event.facebook || null,
                        email: event.email || null,
                        link: event.link || null,
                        schedule: event.schedule || null,
                        alternate_locations: event.alternate_locations || null,
                        price: event.price || null,
                        location,
                        latlon,
                        exceptions: event.exceptions || null,
                        venue_url,
                        isStoryclub: false,
                        isSpecial: false,
                        isMusic: false,
                        isFolk: false,
                        isSession: true
                    };

                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);
                    eventData.isCancelled = reschedule.isCancelled;
                    eventData.rescheduledTo = reschedule.rescheduledTo;
                    eventData.rescheduledToStr = reschedule.rescheduledToStr;
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }

                for (const excDate of exceptions) {
                    const date = parseExceptionDate(excDate);
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const reschedule = evaluateReschedule(startDate, endDate, date, exceptions);

                    if (reschedule.isRescheduled) {
                        const eventData = {
                            name: event.name,
                            date: reschedule.rescheduledTo,
                            time: event.time || null,
                            club: event.club,
                            facebook: event.facebook || null,
                            email: event.email || null,
                            link: event.link || null,
                            schedule: event.schedule || null,
                            price: event.price || null,
                            location: location,
                            latlon: latlon,
                            exceptions: event.exceptions || null,
                            venue_url: venue_url,
                            isRescheduled: true,
                            rescheduledTo: reschedule.rescheduledTo,
                            rescheduledToStr: reschedule.rescheduledToStr,
                            isStoryclub: false,
                            isSpecial: false,
                            isMusic: false,
                            isFolk: false,
                            isSession: true
                        };
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);

            renderEventsList(allEventsData);
            // Zoom map to fit all events
            fitMapToEvents();
        }

    function togglePinMapView() {
        mapViewPinned = document.getElementById('pinMapView').checked;

        if (mapViewPinned) {
            // Save current map view
            pinnedMapView = {
                center: map.getCenter(),
                zoom: map.getZoom()
            };
            console.log('Map view pinned:', pinnedMapView);
        } else {
            pinnedMapView = null;
            console.log('Map view unpinned - fitting to current events');
            // When unpinning, immediately fit to current events
            fitMapToEvents();
        }
    }

    function fitMapToEvents() {
            // If map view is pinned, don't auto-zoom
            if (mapViewPinned && pinnedMapView) {
                map.setView(pinnedMapView.center, pinnedMapView.zoom);
                return;
            }

            // Get all events with valid coordinates
            const eventsWithCoords = allEventsData.filter(event => event.coords);

            if (eventsWithCoords.length === 0) {
                // No events with coordinates, zoom to UK
                map.setView([53.0, -2.0], 6);
                return;
            }

            if (eventsWithCoords.length === 1) {
                // Only one event, zoom to it
                const event = eventsWithCoords[0];
                map.setView([event.coords.lat, event.coords.lon], 12);
                return;
            }

            // Multiple events - fit bounds to show all
            const bounds = L.latLngBounds(
                eventsWithCoords.map(event => [event.coords.lat, event.coords.lon])
            );
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        async function addMarkerForEvent(eventData) {
            // Check if latlon is provided directly
            let coords;
            
            // Accept [lat, lon]
            if (Array.isArray(eventData.latlon) && eventData.latlon.length === 2) {
                coords = {
                    lat: eventData.latlon[0],
                    lon: eventData.latlon[1]
                };
            }

            // Accept { lat, lon }
            else if (
                eventData.latlon &&
                typeof eventData.latlon === 'object' &&
                'lat' in eventData.latlon &&
                'lon' in eventData.latlon
            ) {
                coords = {
                    lat: eventData.latlon.lat,
                    lon: eventData.latlon.lon
                };
            }

            else {
                console.warn(`No usable coordinates for event: ${eventData.name} at ${eventData.location}`);
                return;
            }

            if (coords) {
                eventData.coords = coords;

                // Color coding: grey for story clubs, green for special events, blue for music
                const markerColor =
                    eventData.isSession ? '#90ee90' :
                        eventData.isFolk ? '#8b4513' :
                            eventData.isMusic ? '#443cd7' :
                                eventData.isSpecial ? '#4CAF50' :
                                    '#808080';


                const isStory = eventData.isStoryclub;
                const radius = // if required have different size markers
                    isStory ? 8 :
                        eventData.isSpecial ? 8 :
                            eventData.isMusic ? 8 :
                                5;

                const marker = L.circleMarker([coords.lat, coords.lon], {
                    radius: radius,
                    fillColor: markerColor,
                    color:  '#fff', // isStory ? '#666' : '#fff',,
                    weight: 2,
                    opacity: 1,
                    fillOpacity: isStory ? 0.7 : 0.8
                }).addTo(map);

                const popupContent = `
                    <div class="popup-content">
                        <h3>${eventData.name}</h3>
                        <p><strong>${formatDate(eventData.date)}</strong></p>
                        <p>${eventData.location}</p>
                        ${eventData.performer ? `<p><em>${eventData.performer}</em></p>` : ''}
                    </div>
                `;

                marker.bindPopup(popupContent);
                marker.eventData = eventData;

                marker.on('click', () => {
                    highlightEvent(eventData);
                });

                markers.push(marker);
            }
        }

        function updateMapView() {
            // Filter events by map bounds
            const bounds = map.getBounds();
            const visibleEvents = allEventsData.filter(event => {
                // Always show events with "Various" location and no coords
                if (!event.coords && event.location && event.location.startsWith('Various')) {
                    return true;
                }
                if (!event.coords) return false;
                return bounds.contains([event.coords.lat, event.coords.lon]);
            });

            console.log(`Events in map view: ${visibleEvents.length} of ${allEventsData.length}`);
            renderEventsList(visibleEvents);
        }

        function toggleEventExpandable(eventId, event) {
                event.stopPropagation(); // Prevent map zoom when clicking the button
                const expandable = document.getElementById(eventId);
                if (expandable) {
                    if (expandable.style.display === 'none') {
                        expandable.style.display = 'block';
                    } else {
                        expandable.style.display = 'none';
                    }
                }
            }

    function renderEventsList(eventsToShow) {

        const eventsList = document.getElementById('eventsList');
        const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        if (eventsToShow.length === 0) {
            eventsList.innerHTML = '<div class="no-events">No events in this view</div>';
            return;
        }

        console.log(`Rendering ${eventsToShow.length} events`);

        eventsList.innerHTML = eventsToShow.map(event => {
            const dayName = daysOfWeek[event.date.getDay()];
            const day = event.date.getDate();
            const month = months[event.date.getMonth()];
            const year = event.date.getFullYear();
            const scheduleText = event.schedule ? ` (${event.schedule})` : '';

            const storyclubClass = event.isStoryclub ? ' storyclub' : '';
            const specialClass = event.isSpecial ? ' special' : '';
            const musicClass = event.isMusic ? ' music' : '';
            const folkClass = event.isFolk ? ' folk' : '';
            const sessionClass = event.isSession ? ' session' : '';

            // Add Facebook link if available (for regular facebook page/group)
            let facebookLink = '';
            if (event.facebook && event.facebook.trim()) {
                const fbUrl = event.facebook.startsWith('http')
                    ? event.facebook
                    : `https://facebook.com/${event.facebook}`;
                facebookLink = `<a href="${fbUrl}" target="_blank" class="event-facebook" title="Facebook" onclick="event.stopPropagation()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg></a>`;
            }

            // Add email link if available
            let emailLink = '';
            if (event.email && event.email.trim()) {
                emailLink = `<a href="mailto:${event.email}" class="event-email" title="Email" onclick="event.stopPropagation()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a>`;
            }

            // Add website link if available (but not if it's the same as the main event link)
            let websiteLink = '';
            if (event.link && event.link.trim()) {
                websiteLink = `<a href="${event.link}" target="_blank" class="event-website" title="Website" onclick="event.stopPropagation()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg></a>`;
            }

            // Combine all icons
            const allIcons = websiteLink + emailLink + facebookLink;

            // Build the tickets/event line for special events
            let ticketsEventLine = '';
            if ((event.isSpecial) || (event.isMusic)) {
                let fbEventIcon = '';
                if (event.fb_event) {
                    const fbEventUrl = `https://www.facebook.com/events/${event.fb_event}`;
                    fbEventIcon = `<a href="${fbEventUrl}" target="_blank" class="event-facebook-inline" title="Facebook Event" onclick="event.stopPropagation()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg></a>`;
                }

                let ticketText = '';
                if (event.ticket_url && event.ticket_url.trim()) {
                    ticketText = `<a href="${event.ticket_url}" target="_blank">Tickets available here</a>`;
                }

                // Combine with separator if both exist
                if (fbEventIcon && ticketText) {
                    ticketsEventLine = `<div class="event-tickets">${ticketText} <span class="separator">|</span> ${fbEventIcon}</div>`;
                } else if (fbEventIcon || ticketText) {
                    ticketsEventLine = `<div class="event-tickets">${fbEventIcon}${ticketText}</div>`;
                }
            }

            // Process location with venue link if available
            let locationText = '';
            if (event.location) {
                let locationDisplay = event.location;
                if (event.venue_url && event.venue_url.trim()) {
                    // Extract venue name (text before first comma, or entire location if no comma)
                    const commaIndex = event.location.indexOf(',');
                    const venueName = commaIndex > 0 ? event.location.substring(0, commaIndex) : event.location;
                    const restOfLocation = commaIndex > 0 ? event.location.substring(commaIndex) : '';
                    locationDisplay = `<a href="${event.venue_url}" target="_blank" style="text-decoration: none; color: inherit;"><strong>${venueName}</strong></a>${restOfLocation}`;

                }
                locationText = `<div class="event-location">${locationDisplay}</div>`;
            }

            let priceText = '';
            if (event.price && event.price.trim()) {
                priceText = ` ‚Ä¢ ${event.price}`;
            }

            let timeText = '';
            if (event.time && event.time.trim()) {
                timeText = ` ‚Ä¢ ${event.time}`;
            }

            // Check if there's expandable content (flyer or description)
            const hasExpandableContent = (event.event_flyer && event.event_flyer.trim()) ||
                (event.description && event.description.trim());

            const expandableId = hasExpandableContent ? `event-expand-${Math.random().toString(36).substr(2, 9)}` : '';

            let expandButton = '';
            let expandableContent = '';

            if (hasExpandableContent) {
                expandButton = ` <div class="event-expand-btn" onclick="toggleEventExpandable('${expandableId}', event)">More info...</div>`;

                let flyerHtml = '';
                if (event.event_flyer && event.event_flyer.trim()) {
                    flyerHtml = `<img src="./storyclub_assets/event_flyers/${event.event_flyer}" alt="${event.name} flyer" class="event-flyer-image">`;
                }

                let descriptionHtml = '';
                if (event.description && event.description.trim()) {
                    const paragraphs = event.description.split('\n\n\n\n').map(p =>
                        p.trim() ? `<p>${p.replace(/\n\n/g, '<br>')}</p>` : ''
                    ).join('');
                    descriptionHtml = `<div class="event-description">${paragraphs}</div>`;
                }

                expandableContent = `
                <div class="event-expandable" id="${expandableId}" style="display: none;">
                    ${descriptionHtml}
                    ${flyerHtml}
                </div>
            `;
            }

            let storiesWelcomeBadge = '';
            if (event.isFolk && event.storiesWelcome) {
                storiesWelcomeBadge = ' <span style="background: rgba(76, 175, 80, 0.3); padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">üìñ Stories Welcome</span>';
            }

            let byInvitationBadge = '';
            if (event.isFolk && event.byInvitation) {
                byInvitationBadge = ' <span style="background: rgba(76, 175, 80, 0.3); padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">By Invitation</span>';
            }
            return `
            <div class="event${storyclubClass}${specialClass}${musicClass}${folkClass}${sessionClass}" 
                 onclick="zoomToEvent(${event.coords?.lat}, ${event.coords?.lon})"
                 data-event-id="${event.name}-${event.date.getTime()}">
                <div class="event-name">${event.name}${storiesWelcomeBadge}${byInvitationBadge} ${allIcons}</div>
                ${event.performer ? `<div style="font-style: italic;">${event.performer}</div>` : ''}
                ${locationText}
                <div class="event-date">${event.isCancelled ? `<span style="text-decoration: line-through; color: #999;">${dayName}, ${day} ${month} ${year} <em>${scheduleText}</em></span>` : `${dayName}, ${day} ${month} ${year}<em>${event.isRescheduled ? '' : scheduleText}</em>`}${event.isCancelled && event.rescheduledTo ? ` <span style="color: #d32f2f; font-weight: bold;">(Rescheduled to ${event.rescheduledToStr})</span>` : ''}${event.isRescheduled ? ` <span style="color: #2e7d32; font-style: italic;">(usually ${event.schedule})</span>` : ''}${timeText}${priceText}</div>
                ${ticketsEventLine} ${expandButton}
            </div>
            ${expandableContent}
        `;
        }).join('');

        filterEvents();
    }

        function zoomToEvent(lat, lon) {
            if (lat && lon) {
                map.setView([lat, lon], 13);
            }
        }

        function highlightEvent(eventData) {
            const eventId = `${eventData.name}-${eventData.date.getTime()}`;
            document.querySelectorAll('.event').forEach(el => el.classList.remove('highlighted'));
            const eventEl = document.querySelector(`[data-event-id="${eventId}"]`);
            if (eventEl) {
                eventEl.classList.add('highlighted');
                eventEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function formatDate(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${days[date.getDay()]}, ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function filterEvents() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const specialOn = document.getElementById('specialOn').checked;
            const storyclubsOn = document.getElementById('storyclubsOn').checked;
            const showMusic = document.getElementById('showMusic').checked;
            const showFolk = document.getElementById('showFolk').checked;
            const showSessions = document.getElementById('showSessions').checked;

            console.log('Filter settings:', { specialOn, storyclubsOn, showMusic });

            // Filter event list items
            const allEventElements = document.querySelectorAll('.event');
            console.log(`Total event elements: ${allEventElements.length}`);

            allEventElements.forEach(event => {
                let visible = false;

                const isStoryclub = event.classList.contains('storyclub');
                const isSpecial = event.classList.contains('special');
                const isMusic = event.classList.contains('music');
                const isFolk = event.classList.contains('folk');
                const isSession = event.classList.contains('session');

                // Show event if its type checkbox is checked
                if (storyclubsOn && isStoryclub) visible = true;
                if (specialOn && isSpecial) visible = true;
                if (showMusic && isMusic) visible = true;
                if (showFolk && isFolk) visible = true;
                if (showSessions && isSession) visible = true;

                // Apply search filter if search term exists
                if (visible && searchTerm) {
                    const text = event.textContent.toLowerCase();
                    visible = text.includes(searchTerm);
                }

                event.classList.toggle('hidden', !visible);
            });

            // Filter map markers
            markers.forEach(marker => {
                const eventData = marker.eventData;
                let visible = false;

                if (storyclubsOn && eventData.isStoryclub) visible = true;
                if (specialOn && eventData.isSpecial) visible = true;
                if (showMusic && eventData.isMusic) visible = true;
                if (showFolk && eventData.isFolk) visible = true;
                if (showSessions && eventData.isSession) visible = true;

                // Apply search filter if search term exists
                if (visible && searchTerm) {
                    const searchableText = `${eventData.name} ${eventData.location} ${eventData.performer || ''}`.toLowerCase();
                    visible = searchableText.includes(searchTerm);
                }

                // Show/hide marker based on filter
                if (visible) {
                    marker.setStyle({ opacity: 1, fillOpacity: 0.8 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            });

            // Count visible events
            const visibleCount = document.querySelectorAll('.event:not(.hidden)').length;
            console.log(`Visible events after filtering: ${visibleCount}`);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';

            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput) {
                const startDate = new Date(startInput);
                const endDate = endInput
                    ? new Date(endInput)
                    : getWeekEnd(getWeekStart(startDate));

                // Re-run date-based display
                displayEvents(startDate, endDate);

                // Clear active week buttons (optional UX choice)
                document.querySelectorAll('.button-group button')
                    .forEach(btn => btn.classList.remove('active'));
            } else {
                // Fallback (should rarely happen)
                filterEvents();
            }
        }

        async function searchAllUpcoming() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();

            if (!searchTerm) {
                alert('Please enter a search term first');
                return;
            }

            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Search 2 years into the future
            const futureDate = new Date(today);
            futureDate.setFullYear(futureDate.getFullYear() + 2);

            // Clear the list and markers
            allEventsData = [];
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // Check if story clubs filter is enabled
            const storyclubsOn = document.getElementById('storyclubsOn').checked;

            // Search recurring story club events if enabled
            if (storyclubsOn) {
                for (const event of eventsData.events || []) {
                    const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                    if (searchableText.includes(searchTerm)) {
                        // Find the next occurrence of this recurring event
                        const dates = parseSchedule(event.schedule, today, futureDate);
                        if (dates.length > 0) {
                            // Just show the first (next) occurrence
                            const nextDate = dates[0];
                            const eventData = {
                                name: event.name,
                                date: nextDate,
                                time: event.time || null,
                                location: event.location,
                                club: event.club,
                                price: event.price || null,
                                facebook: event.facebook || null,
                                email: event.email || null,
                                link: event.link || null,
                                schedule: event.schedule || null,
                                latlon: event.latlon || null,
                                venue_url: event.venue_url || null,
                                isStoryclub: true,
                                isSpecial: false,
                                isMusic: false
                            };
                            allEventsData.push(eventData);
                            await addMarkerForEvent(eventData);
                        }
                    }
                }
            }

            // Only load specific events and music events (not recurring story clubs)
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        time: event.time || null,
                        location: event.location,
                        performer: event.performer,
                        description: event.description || null,
                        event_flyer: event.event_flyer || null,
                        latlon: event.latlon || null,
                        fb_event: event.fb_event || null,
                        ticket_url: event.ticket_url || null,
                        price: event.price || null,
                        venue_url: event.venue_url || null,
                        isStoryclub: false,
                        isSpecial: true,
                        isMusic: false
                    };

                    // Check if matches search term
                    const searchableText = `${eventData.name} ${eventData.location} ${eventData.performer || ''}`.toLowerCase();
                    console.log(searchableText,"....", searchTerm )
                    if (searchableText.includes(searchTerm.toLowerCase())) {
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            for (const event of eventsData.musicEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        time: event.time || null,
                        location: event.location,
                        performer: event.performer,
                        description: event.description || null,
                        event_flyer: event.event_flyer || null,
                        fb_event: event.fb_event || null,
                        ticket_url: event.ticket_url || null,
                        price: event.price || null,
                        latlon: event.latlon || null,
                        venue_url: event.venue_url || null,
                        isStoryclub: false,
                        isSpecial: false,
                        isMusic: true
                    };

                    // Check if matches search term
                    const searchableText = `${eventData.name} ${eventData.location} ${eventData.performer || ''}`.toLowerCase();
                    if (searchableText.includes(searchTerm)) {
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);

            // Update the date inputs to reflect the search range
            updateDateInputs(today, futureDate);

            // Clear any active week button
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));

            renderEventsList(allEventsData);
            fitMapToEvents();

            if (allEventsData.length === 0) {
                eventsList.innerHTML = `<div class="no-events">No upcoming events found matching "${rawSearchTerm}"</div>`;
            }
        }

        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function getWeekEnd(weekStart) {
            const end = new Date(weekStart);
            end.setDate(end.getDate() + 6);
            return end;
        }

        function setActiveMode(mode) {
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            if (mode === 'thisWeek') document.getElementById('thisWeekBtn').classList.add('active');
            else if (mode === 'nextWeek1') document.getElementById('nextWeekBtn').classList.add('active');
            else if (mode === 'nextWeek2') document.getElementById('afterThatWeekBtn').classList.add('active');
            else if (mode === 'nextWeek3') document.getElementById('andAnotherWeekBtn').classList.add('active');
            else if (mode === 'lastWeek1') document.getElementById('lastWeekBtn').classList.add('active');
        }

        function updateDateInputs(startDate, endDate) {
                // Format dates as YYYY-MM-DD for the date inputs
                const formatForInput = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                };

                document.getElementById('startDate').value = formatForInput(startDate);
                document.getElementById('endDate').value = formatForInput(endDate);
            }

        function showThisWeek() {
            const today = new Date();
            const weekStart = getWeekStart(today);
            const weekEnd = getWeekEnd(weekStart);
            updateDateInputs(weekStart, weekEnd); 
            displayEvents(weekStart, weekEnd);
            setActiveMode('thisWeek');
        }

        function showWeek(weeksAhead = 1) {
            const today = new Date();
            const thisWeekStart = getWeekStart(today);
            const targetWeekStart = new Date(thisWeekStart);
            targetWeekStart.setDate(targetWeekStart.getDate() + (7 * weeksAhead));
            const targetWeekEnd = getWeekEnd(targetWeekStart);
            updateDateInputs(targetWeekStart, targetWeekEnd);
            displayEvents(targetWeekStart, targetWeekEnd);
            setActiveMode(weeksAhead > 0 ? `nextWeek${weeksAhead}` : `lastWeek${Math.abs(weeksAhead)}`);
        }

    function showDateRange(clearActiveButton = true) {
        const startInput = document.getElementById('startDate').value;
        const endInput = document.getElementById('endDate').value;

        if (!startInput) {
            alert('Please select at least a start date');
            return;
        }

        const startDate = new Date(startInput);
        const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));
        displayEvents(startDate, endDate);

        // Only clear active button styling when manually using custom date range
        if (clearActiveButton) {
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
        }
    }
    let lastStartDate = '';
    let lastEndDate = '';

    function formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function handleStartDateChange() {
        const startInput = document.getElementById('startDate').value;
        const endInput = document.getElementById('endDate').value;

        if (startInput && endInput) {
            const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
            const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

            const startDate = new Date(startYear, startMonth - 1, startDay);
            const endDate = new Date(endYear, endMonth - 1, endDay);

            // Start date changed - if it's now after end date, adjust end to end of start's week
            if (startDate > endDate) {
                const weekEnd = getWeekEnd(getWeekStart(startDate));
                document.getElementById('endDate').value = formatDateForInput(weekEnd);
            }
        }

        if (startInput) {
            showDateRange(true);
        }
    }

    function handleEndDateChange() {
        const startInput = document.getElementById('startDate').value;
        const endInput = document.getElementById('endDate').value;

        if (startInput && endInput) {
            const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
            const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

            const startDate = new Date(startYear, startMonth - 1, startDay);
            const endDate = new Date(endYear, endMonth - 1, endDay);

            // End date changed - if it's now before start date, adjust start to beginning of end's week
            if (endDate < startDate) {
                const weekStart = getWeekStart(endDate);
                document.getElementById('startDate').value = formatDateForInput(weekStart);
            }
        }

        if (startInput) {
            showDateRange(true);
        }
    }

 function generateShareableURL(startDate, endDate) {
        const formatForInput = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        const params = new URLSearchParams();
        params.set('start', formatForInput(startDate));
        params.set('end', formatForInput(endDate));

        // Add filter states
        params.set('storyclubs', document.getElementById('storyclubsOn').checked ? '1' : '0');
        params.set('special', document.getElementById('specialOn').checked ? '1' : '0');
        params.set('music', document.getElementById('showMusic').checked ? '1' : '0');
        params.set('folk', document.getElementById('showFolk').checked ? '1' : '0');
        params.set('sessions', document.getElementById('showSessions').checked ? '1' : '0');

        const searchTerm = document.getElementById('searchInput').value.trim();
        if (searchTerm) {
            params.set('q', searchTerm);
        }

        return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
    }

        async function copyShareableLink() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select a date range first');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));

            const shareableURL = generateShareableURL(startDate, endDate);

            try {
                await navigator.clipboard.writeText(shareableURL);
                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const tempInput = document.createElement('input');
                tempInput.value = shareableURL;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            }
        }

        function getURLParams() {
                const params = new URLSearchParams(window.location.search);
                const start = params.get('start');
                const end = params.get('end');

                if (start) {
                    const storyclubs = params.get('storyclubs') === '1';
                    const special = params.get('special') === '1';
                    const music = params.get('music') === '1';
                    const folk = params.get('folk') === '1';
                    const sessions = params.get('sessions') === '1';

                    // If none are selected, default storyclubs and special to true
                    const noneSelected = !storyclubs && !special && !music && !folk && !sessions;

                    const q = params.get('q');

                    return {
                        startDate: new Date(start),
                        endDate: end ? new Date(end) : null,
                        storyclubs: noneSelected ? true : storyclubs,
                        special: noneSelected ? true : special,
                        folk: noneSelected ? true : folk,
                        sessions: noneSelected ? true : sessions,
                        music: music,
                        searchTerm: q
                    };
                }
                return null;
            }

        // Initialize
        window.addEventListener('load', async () => {
                await loadEventsData();
                initMap();

                // Check for URL parameters first
                const urlParams = getURLParams();
            if (urlParams) {
                const startDate = urlParams.startDate;
                const endDate = urlParams.endDate || getWeekEnd(getWeekStart(startDate));

                document.getElementById('storyclubsOn').checked = urlParams.storyclubs;
                document.getElementById('specialOn').checked = urlParams.special;
                document.getElementById('showMusic').checked = urlParams.music;
                document.getElementById('showFolk').checked = urlParams.folk;
                document.getElementById('showSessions').checked = urlParams.sessions;

                updateDateInputs(startDate, endDate);

                //  restore search term
                if (urlParams.searchTerm) {
                    document.getElementById('searchInput').value = urlParams.searchTerm;

                    // Behave exactly like "Search All Upcoming"
                    await searchAllUpcoming();
                } else {
                    await displayEvents(startDate, endDate);
                }
            } else {
                showThisWeek();
            }
            });
    </script>
</body>

</html>