<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>New Troubadour Events with Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            color: #333;
            text-align: center;
            margin: 5px 0 10px 0;
        }

        h2 {
            text-align: center;
            font-style: italic;
            color: #898b89;
            margin: 5px 0 20px 0;
            font-size: 18px;
        }

        .layout-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .layout-container {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2e7d32;
            box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.3);
        }

        .date-inputs {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.3s;
        }

        #map-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            height: 600px;
        }

        #map {
            height: 100%;
            border-radius: 4px;
        }

        .events-list {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .event {
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .event:hover {
            background-color: #f0f0f0;
        }

        .event.special {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%);
            border: 2px solid #2e7d32;
            color: white;
        }

        .event.music {
            background: linear-gradient(135deg, #443cd7 0%, #8e9df3 100%);
            border: 2px solid #1006c6;
            color: white;
        }

        .event.highlighted {
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            border-left-width: 8px;
        }

        .event-name {
            font-weight: bold;
            font-size: 16px;
        }

        .event-date {
            margin-top: 5px;
        }


        .event-location {
            color: #777;
            font-style: italic;
            margin-top: 3px;
            font-size: 14px;
        }

        .special .event-location,
        .music .event-location {
            color: #c8e6c9;
        }

        .event.hidden {
            display: none;
        }

        .event-facebook {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-facebook svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook:hover svg {
            fill: #145dbf;
        }


        .event-facebook-inline {
            display: inline-flex;
            text-decoration: none !important;
            border: none !important;
            border-bottom: none !important;
            vertical-align: middle;
        }

        .event-facebook-inline svg {
            width: 20px;
            height: 20px;
            fill: #1877f2;
            transition: fill 0.3s;
        }

        .event-facebook-inline:hover svg {
            fill: #145dbf;
        }


        /* SPECIAL event override ‚Äî white circle, blue F */
        .folk svg,
        .event-facebook-inline svg {
            fill: #ffffff;
            /* make whole shape white */
        }

        /* SPECIAL event + hover (if you want the F to stay blue on hover) */
        .folk svg,
        .event-facebook-inline:hover svg {
            fill: #ffffff;
        }

        /* Then recolor only the F using stroke */
        .folk svg path,
        .event-facebook-inline svg path {
            stroke: #1877f2;
            /* FB blue outline = F shape */
            stroke-width: 2px;
            /* adjust until the ‚ÄúF‚Äù looks right */
            stroke-linejoin: round;
        }

        .event-tickets {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .event-tickets a {
            color: #2e7d32;
            text-decoration: none;
            font-weight: bold;
            border-bottom: 2px solid #4CAF50;
        }

        .event-tickets a {
            color: #ffeb3b;
            border-bottom: 2px solid #fff59d;
        }

        .event-tickets a:hover {
            border-bottom-color: #ffffff;
        }

        .event-badge {
            background: rgba(76, 175, 80, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }


        .event-date-cancelled {
            text-decoration: line-through;
            color: #999;
        }

        .event-date-rescheduled-notice {
            color: #d32f2f;
            font-weight: bold;
        }

        .event-date-usually {
            color: #2e7d32;
            font-style: italic;
        }

        .venue-link {
            text-decoration: none;
            color: inherit;
        }

        .venue-link:hover {
            text-decoration: underline;
        }

        .search-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .event-email,
        .event-website {
            display: inline-block;
            margin-left: 10px;
            text-decoration: none !important;
            vertical-align: middle;
            border: none;
            border-bottom: none !important;
        }

        .event-email svg,
        .event-website svg {
            width: 20px;
            height: 20px;
            transition: fill 0.3s;
        }

        .event-email svg {
            fill: #ffffff;
        }

        .event-email:hover svg {
            fill: #77ee77;
        }

        .event-website svg {
            fill: #555555;
        }

        .event-website:hover svg {
            fill: #1eb868;
        }

        /* Email icon reversed for .event.special */
        /* Normal state inside special event */
        .event.music .event-email svg {
            fill: #77ee77;
            /* inverted from white */
        }

        /* Hover state inside special event */
        .event.music .event-email:hover svg {
            fill: #ffffff;
            /* inverted from #77ee77 */
        }


        /* -------- WEBSITE -------- */

        /* Normal state inside special event */
        .event.music .event-website svg {
            fill: #1eb868;
            /* inverted from #555555 */
        }

        /* Hover state inside special event */
        .event.music .event-website:hover svg {
            fill: #555555;
            /* inverted from #1eb868 */
        }

        .event.folk {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
            border: 2px solid #654321;
            color: white;
        }

        .event.session {
            background: linear-gradient(135deg, #90ee90 0%, #98fb98 100%);
            border: 2px solid #228b22;
            color: #1a5c1a;
        }

        .folk .event-location {
            color: #f5deb3;
        }

        .session .event-location {
            color: #2d5a2d;
        }

        .event.folk .event-email svg {
            fill: #f5deb3;
        }

        .event.folk .event-email:hover svg {
            fill: #ffffff;
        }

        .event.folk .event-website svg {
            fill: #f5deb3;
        }

        .event.folk .event-website:hover svg {
            fill: #ffffff;
        }

        .event.session .event-email svg {
            fill: #228b22;
        }

        .event.session .event-email:hover svg {
            fill: #1a5c1a;
        }

        .event.session .event-website svg {
            fill: #228b22;
        }

        .event.session .event-website:hover svg {
            fill: #1a5c1a;
        }

        .search-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        #searchInput {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .no-events {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .leaflet-popup-content {
            margin: 10px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }

        .popup-content p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            button {
                padding: 8px 6px;
                font-size: 11px;
            }

            .date-inputs {
                grid-template-columns: auto 1fr;
                gap: 8px;
            }
        }

        .event-expand-btn {
            display: block;
            margin-top: 12px;
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            width: fit-content;
        }

        .event-expand-btn:hover {
            border-bottom-color: #ffffff;
        }

        .event-tickets .separator {
            color: #ffeb3b;
            margin: 0 8px;
        }

        .event.special .event-expand-btn,
        .event.music .event-expand-btn,
        .event.folk .event-expand-btn,
        .event.session .event-expand-btn {
            background: rgba(255, 255, 255, 0.3);
        }

        .event.special .event-expand-btn:hover,
        .event.music .event-expand-btn:hover,
        .event.folk .event-expand-btn:hover,
        .event.session .event-expand-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .event-expandable {
            margin-top: 10px;
            padding: 15px;
            background-color: #ffffff;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            margin-bottom: 10px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }

            to {
                opacity: 1;
                max-height: 1000px;
            }
        }

        .event-description {
            margin-bottom: 15px;
            color: #333;
            line-height: 1.6;
        }

        .event-description p {
            margin: 0 0 10px 0;
        }

        .event-flyer-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }


        .info-banner-tabs {
            background: white;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .info-banner-tabs-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #4CAF50 0%, #66bb6a 100%);
            color: white;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }


        .tab-content-area {
            padding: 20px;
            border: 2px solid #4CAF50;
            border-top: none;
            background-color: #f9f9f9;
            animation: slideDown 0.3s ease-out;
        }

        .tab-content-area p {
            margin: 0 0 15px 0;
            line-height: 1.6;
            color: #333;
        }

        .tab-content-area p:last-child {
            margin-bottom: 0;
        }
    </style>
</head>

<body>
    <h1>The New Troubadours ‚Äî Storytelling, Music and Punk Poet Events Calendar (UK)</h1>
    <h2>Appropriate all ages, aimed at adults.</h2>

    <div class="controls">
        <div class="button-group">
            <button id="lastWeekBtn" onclick="showWeek(-1)">Last Week</button>
            <button id="thisWeekBtn" onclick="showThisWeek()">This Week</button>
            <button id="nextWeekBtn" onclick="showWeek()">Next Week</button>
            <button id="afterThatWeekBtn" onclick="showWeek(2)">Week After</button>
            <button id="andAnotherWeekBtn" onclick="showWeek(3)">And Another</button>
        </div>
        <div class="date-inputs">
            <label>From:</label>
            <input type="date" id="startDate" onchange="handleStartDateChange()">
            <label>To:</label>
            <input type="date" id="endDate" onchange="handleEndDateChange()">
            <button id="showBtn" onclick="showDateRange()">Show Events</button>
        </div>

        <div class="search-controls">
            <div class="search-row">
                <input type="text" id="searchInput" placeholder="Search events..." onkeyup="filterEvents()">
                <button onclick="clearSearch()">Clear</button>
                <button onclick="searchAllUpcoming()" style="background-color: #2e7d32;">Search All Upcoming</button>
            </div>
            <div class="filter-row">
                <label>
                    <input type="checkbox" checked id="storyclubsOn" onchange="filterEvents()">
                    Story clubs
                </label>
                <label>
                    <input type="checkbox" checked id="specialOn" onchange="filterEvents()">
                    Story shows
                </label>
                <label>
                    <input type="checkbox" id="showFolk" onchange="filterEvents()">
                    Folk clubs
                </label>
                <label>
                    <input type="checkbox" id="showSessions" onchange="filterEvents()">
                    Irish sessions
                </label>
                <label>
                    <input type="checkbox" id="showMusic" onchange="filterEvents()">
                    Music events
                </label>
            </div>
        </div>
    </div>

    <div
        style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="pinMapView" onchange="togglePinMapView()">
            <span>Pin current map view (don't auto-zoom when changing dates)</span>
        </label>
        <div style="display: flex; gap: 10px; align-items: center;">
            <button onclick="copyShareableLink()" style="background-color: #2196F3;">
                üìã Copy Shareable Link
            </button>
            <span id="copyFeedback" style="color: #4CAF50; font-size: 14px; display: none;">‚úì Link copied!</span>
        </div>
    </div>

    <div class="layout-container">
        <div id="map-container">
            <div id="map"></div>
        </div>
        <div class="events-list" id="eventsList"></div>

    </div>

    <div class="info-banner-tabs">
        <div class="info-banner-tabs-header">
            <span class="header-label">What is/are:</span>
            <button class="header-tab-button" onclick="toggleTabContent('storytelling')">storytelling?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('circles')">story circles / clubs?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('performance')">performance
                storytelling?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('storytellingshows')">storytelling
                shows?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('folknopenmic')">folk club etiquette?</button>
            <span class="separator">|</span>
            <button class="header-tab-button" onclick="toggleTabContent('musicpolicy')">music policy?</button>
        </div>

        <div class="tab-content-area" id="storytelling" style="display: none;">
            <p>For starters, <em>storytelling</em> is not (just) for children... It's an entertaining way of passing the
                time. But it's also a lot more than that: a way of sharing epic tales and passing on common sense
                smarts, explaining the landscape, recounting local legends and keeping the memory of people and place
                alive.</p>
        </div>

        <div class="tab-content-area" id="circles" style="display: none;">
            <p><em>Story circles</em> and <em>story clubs</em> are often informal gatherings of tellers and listeners
                who meet up every so often, in a casual setting, to sit around a table and share tales that last 5 to 8
                minutes. Stories are <em>told</em> rather than read, and often take the form of folk or traditional
                tales, as well as myths, legends, and lies, that have been "heard", or "found", rather than "authored",
                even though they may have been heavily worked on by the teller. By agreement, some story clubs or story
                circles may provide opportunities for longer stories to be told. Some story clubs may feature
                <em>performance storytelling</em> from local storytellers or guest storytellers, as well open
                performance storytelling floor spots.</em>
            </p>
        </div>

        <div class="tab-content-area" id="performance" style="display: none;">
            <p><em>Performance storytelling</em> moves the teller or tellers rather more to centre stage, adopting a
                more formal setting than a sharing of stories in a story circle, and with the teller clearly taking on a
                performer role. Stories often take longer in the telling than tales told in story circles, 8 to 15
                minutes or so, or even longer, up to an hour for many longer traditional tales.</p>
        </div>

        <div class="tab-content-area" id="storytellingshows" style="display: none;">
            <p>A <em>storytelling show</em> is a performance event in which one or more storytellers tell one or more
                tales in a formal or semi-formal setting. A storytelling set, or show, show often shapes several stories
                to fit an overarching narrative or theme. Not comedy, not theatre, storytelling shows take the performer
                and audience alike into an eternal moment of remembered times and places that never existed. Which is to
                say, into a time of <em>once</em>...</p>
        </div>

        <div class="tab-content-area" id="folknopenmic" style="display: none;">
            <p>For the purpose of this list, <em>folk nights</em>, <em>folk clubs</em> and <em>open mics</em> are open
                invitation events where storytellers have previously had a slot. (Folk nights as listed here often
                define "folk music" in quite broad terms..) <em>Folk nights</em> often have a one or two song policy, so
                a short 3-5 minute tale. By invitation, (particularly if you have travelled and can demonstrate a
                performance reputation elsewhere) you may be able to get a longer slot. <em>Folk clubs</em> are slightly
                more formal and more traditional in their
                repertoire. Sometimes you might get a second turn, which means you can split a longer tale at a
                cliff-hanger. <em>Open mics</em> are typically amplified events, though you can often get away with not
                using the mic. The slots may be more generous, with an up to four song policy, or a 10-12 minute tale,
                though you should probably work up to that over several sessions to build trust with the organiser and
                from the audience. To take part in any of these events, give your name to the person running the
                club/session. Contacting organisers beforehand can also put them on the look out for you.</p>
        </div>

        <div class="tab-content-area" id="musicpolicy" style="display: none;">
            <p>The performers listed under the <em>music</em> filter are : a) ones that I like and don't want to miss if
                they
                happen to be playing somewhere where I'm near; and b) that I can imagine as part of a small (intimate)
                venue
                <em>New Troubadours</em> acoustic set billing with support from, or co-billing with, a storyteller.
            </p>
            <p>Typically, they are likely to fall into the folk/protest/narrative ballad singer category. Although, not
                necessarily...</p>
        </div>
    </div>

    <div class="about" id="colophon">
        <p><em>Hacked together by Tony Hirst in conversation with Claude.ai, inspired by <a
                    href="https://www.facebook.com/groups/societyforstorytelling/posts/10172947366465461/">a list</a> of
                storytelling club dates posted by Peter Giles to the Society for Storytelling Facebook group on
                Saturday, November 29th, 2025.</em></p>
        <p><em>For corrections, additions, removals, etc., email: <tt>montystoryteller AT gmail DOT com</tt> / web: <a
                    href="https://montystoryteller.org/"><tt>montystoryteller.org</tt></a> / fb: <a
                    href="https://www.facebook.com/montystoryteller/"><tt>montystoryteller</tt></a> / insta: <a
                    href="https://www.instagram.com/montystoryteller/"><tt>montystoryteller</tt></a>. If you're a
                regular teller at a folk night / open mic that would welcome other tellers, I can add those to the list
                too... That said, this list is opinionated. So for folk nights and open mics, I may not add the listing
                until I've visited to check that tellers are welcome.</em></p>
        <p><em>Show your appreciation by booking me for a gig, or by buying a little something for yourself: <a
                    href="https://www.amazon.co.uk/dp/B0FVYBY4V8">Island Tales</a>; <a
                    href="https://www.amazon.co.uk/dp/B0FY3TZW81">Protest Tales</a>; <a
                    href="https://www.amazon.co.uk/dp/B0FW286JLD">Dark Tales</a>.</em></p>
        <p><tt>If you're looking for a ticketing service, how about <a
                    href="https://get.tickettailor.com/z0iazwduw3fe"><strong>TicketTailor</strong> <em>[affiliate
                        link]</em></a>?</tt></p>
        <p>Ticket links to <a href="https://clients.wegottickets.com/">WeGotTickets</a> are affiliate links tied to this website. I get a few pennies commission for any tickets purchased on <a href="https://clients.wegottickets.com/">WeGotTickets</a> from clicks through to that website that originated on this website.</p>
        <p><em><tt>This website does not collect cookies or tracking information.</tt></em></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        let map;
        let markers = [];
        let allEventsData = [];
        let isGeocoding = false;
        let eventsData = null;

        let venuesLookup = {};
        let performersLookup = {};
        let toursLookup = {};

        let mapViewPinned = false;
        let pinnedMapView = null;

        const UK_IRELAND_BOUNDS = L.latLngBounds(
            [49.5, -11.0],  // SW corner (Atlantic)
            [61.0, 2.5]     // NE corner (North Sea)
        );

        const EVENT_TYPES = {
            SESSION: 'session',
            FOLK: 'folk',
            MUSIC: 'music',
            SPECIAL: 'special',
            STORYCLUB: 'storyclub'
        };



        /**
         * Sanitize HTML to prevent XSS attacks
         * @param {string} text - The text to sanitize
         * @returns {string} - Sanitized text
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Validate and sanitize URL
         * @param {string} url - The URL to validate
         * @returns {string|null} - Sanitized URL or null if invalid
         */
        function sanitizeUrl(url) {
            if (!url) return null;

            // Remove any whitespace
            url = url.trim();

            // Only allow http, https, and mailto protocols
            const allowedProtocols = ['http:', 'https:', 'mailto:'];

            try {
                const urlObj = new URL(url, window.location.origin);

                if (!allowedProtocols.includes(urlObj.protocol)) {
                    console.warn('Blocked potentially dangerous URL:', url);
                    return null;
                }

                return urlObj.href;
            } catch (e) {
                console.warn('Invalid URL:', url);
                return null;
            }
        }


        // Load events from JSON file
        async function loadEventsData() {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`events_normalized.json?v=${cacheBuster}`);
                if (response.ok) {
                    eventsData = await response.json();
                    toursLookup = eventsData.tours || {};

                    console.log(`‚úì Loaded events from JSON:`);
                    if (eventsData.venues) {
                        venuesLookup = eventsData.venues;
                        console.log(`  - ${Object.keys(venuesLookup).length} venues`);
                    }
                    if (eventsData.performers) {
                        performersLookup = eventsData.performers;
                        console.log(`  - ${Object.keys(performersLookup).length} performers`);
                    }
                    console.log(`  - ${eventsData.events?.length || 0} recurring events`);
                    console.log(`  - ${eventsData.specificEvents?.length || 0} specific events`);
                    console.log(`  - ${eventsData.musicEvents?.length || 0} music events`);
                    console.log(`  - ${eventsData.folkNights?.length || 0} folk nights`);
                    console.log(`  - ${eventsData.irishSessions?.length || 0} Irish sessions`);

                    // Flag events with missing geocode
                    const checkMissing = (eventsList, label) => {
                        const missing = eventsList?.filter(e => e.geocode_missing) || [];
                        if (missing.length > 0) {
                            console.warn(`‚ö† ${missing.length} ${label} missing geocode data:`);
                            missing.forEach(e => console.warn(`  - ${e.name}: ${e.location}`));
                        }
                    };

                    checkMissing(eventsData.events, 'recurring events');
                    checkMissing(eventsData.specificEvents, 'specific events');
                    checkMissing(eventsData.musicEvents, 'music events');

                    return eventsData;
                } else {
                    console.error('Failed to load events_combined.json');
                    return null;
                }
            } catch (error) {
                console.error('Error loading events:', error);
                return null;
            }
        }

        function extractPostcodeArea(location) {
            if (!location) return '';
            const parts = location.split(',');
            const lastPart = parts[parts.length - 1].trim();
            const postcodeMatch = lastPart.match(/^([A-Z]+)/i);
            return postcodeMatch ? postcodeMatch[1] : '';
        }

        function initMap() {
            map = L.map('map', {
                maxBounds: UK_IRELAND_BOUNDS,
                maxBoundsViscosity: 1.0, minZoom: 5,
                maxZoom: 16
            }).setView([53.0, -2.0], 6); // Center on UK

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            map.on('moveend', updateMapView);
        }

        function findNthDayInMonth(year, month, targetDay, occurrence) {
            const lastDay = new Date(year, month + 1, 0);

            if (occurrence === 'last') {
                // Count backwards from end of month
                for (let d = lastDay.getDate(); d >= 1; d--) {
                    const testDate = new Date(year, month, d);
                    testDate.setHours(0, 0, 0, 0);
                    if (testDate.getDay() === targetDay) {
                        return testDate;
                    }
                }
            } else {
                // Count forwards from start of month
                let count = 0;
                for (let d = 1; d <= lastDay.getDate(); d++) {
                    const testDate = new Date(year, month, d);
                    testDate.setHours(0, 0, 0, 0);
                    if (testDate.getDay() === targetDay) {
                        count++;
                        if (count === occurrence) {
                            return testDate;
                        }
                    }
                }
            }
            return null;
        }

        function parseSchedule(schedule, startDate, endDate) {
            const results = [];

            // Normalize dates to midnight for consistent comparison
            const normalizeDate = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d;
            };

            const normalizedStart = normalizeDate(startDate);
            const normalizedEnd = normalizeDate(endDate);

            // Handle specific dates (DD/MM/YYYY)
            if (schedule.includes('/')) {
                const [day, month, year] = schedule.split('/').map(num => parseInt(num, 10));
                const specificDate = normalizeDate(new Date(year, month - 1, day));
                if (specificDate >= normalizedStart && specificDate <= normalizedEnd) {
                    results.push(specificDate);
                }
                return results;
            }


            // Handle "every [dayname]" schedules
            if (schedule.toLowerCase().startsWith('every ')) {
                const dayName = schedule.toLowerCase().replace('every ', '').trim();
                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                if (targetDay === undefined) {
                    console.warn(`Invalid day name in schedule: ${schedule}`);
                    return results;
                }

                const current = new Date(normalizedStart);

                // Find the first occurrence of the target day on or after the start date
                while (current.getDay() !== targetDay) {
                    current.setDate(current.getDate() + 1);
                }

                // Add all occurrences of this day within the date range
                while (current <= normalizedEnd) {
                    const eventDate = normalizeDate(new Date(current));
                    if (eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                        results.push(eventDate);
                    }
                    current.setDate(current.getDate() + 7); // Move to next week
                }

                return results;
            }

            // Handle multiple occurrences in same month (e.g., "1st and 3rd wednesday")
            // TO DO - this only really handles a case of X, or, X and Y?
            if (schedule.toLowerCase().includes(' and ')) {
                const [occurrence1Str, rest] = schedule.toLowerCase().split(' and ');
                const parts = rest.trim().split(/\s+/);
                const occurrence2Str = parts[0];
                const dayName = parts[1];

                const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                const targetDay = dayMap[dayName];

                const occurrenceMap = { '1st': 1, '2nd': 2, '3rd': 3, '4th': 4, 'last': 'last' };
                const occurrence1 = occurrenceMap[occurrence1Str.trim()];
                const occurrence2 = occurrenceMap[occurrence2Str.trim()];

                const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                while (current <= extendedEnd) {
                    const year = current.getFullYear();
                    const month = current.getMonth();
                    const lastDay = new Date(year, month + 1, 0);

                    // Find both occurrences
                    const occurrences = [occurrence1, occurrence2];

                    occurrences.forEach(occ => {
                        const eventDate = findNthDayInMonth(year, month, targetDay, occ);

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }
                    });

                    current.setMonth(current.getMonth() + 1);
                }

                return results.sort((a, b) => a - b);
            }

            // Handle alternating schedules (e.g., "1st wednesday (even months) | 1st thursday (odd months)")
            if (schedule.includes('|')) {
                const parts = schedule.split('|').map(s => s.trim());

                parts.forEach(part => {
                    // Extract the pattern and condition
                    const match = part.match(/^(.+?)\s*\((\w+)\s+months\)$/i);
                    if (!match) return;

                    const pattern = match[1].trim(); // e.g., "1st wednesday"
                    const condition = match[2].toLowerCase(); // "even" or "odd"

                    // Parse the base pattern
                    const [occurrence, dayName] = pattern.toLowerCase().split(/\s+/);
                    const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
                    const targetDay = dayMap[dayName];

                    const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
                    const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

                    while (current <= extendedEnd) {
                        const year = current.getFullYear();
                        const month = current.getMonth();

                        // Check if this month matches the condition
                        const monthNumber = month + 1; // 1-12
                        const isEvenMonth = monthNumber % 2 === 0;
                        const matchesCondition = (condition === 'even' && isEvenMonth) ||
                            (condition === 'odd' && !isEvenMonth);

                        if (!matchesCondition) {
                            current.setMonth(current.getMonth() + 1);
                            continue;
                        }

                        const occurrenceNum = occurrence === 'last' ? 'last' :
                            occurrence === '1st' ? 1 :
                                occurrence === '2nd' ? 2 :
                                    occurrence === '3rd' ? 3 : 4;

                        const eventDate = findNthDayInMonth(year, month, targetDay, occurrenceNum);

                        if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                            results.push(eventDate);
                        }

                        current.setMonth(current.getMonth() + 1);
                    }
                });

                return results.sort((a, b) => a - b);
            }

            // Handle standard recurring schedules (existing code)
            const [occurrence, dayName] = schedule.toLowerCase().split(/\s+/);
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const targetDay = dayMap[dayName];

            const current = new Date(normalizedStart.getFullYear(), normalizedStart.getMonth() - 1, 1);
            const extendedEnd = new Date(normalizedEnd.getFullYear(), normalizedEnd.getMonth() + 1, 0);

            while (current <= extendedEnd) {
                const year = current.getFullYear();
                const month = current.getMonth();

                const occurrenceNum = occurrence === 'last' ? 'last' :
                    occurrence === '1st' ? 1 :
                        occurrence === '2nd' ? 2 :
                            occurrence === '3rd' ? 3 : 4;

                const eventDate = findNthDayInMonth(year, month, targetDay, occurrenceNum);

                if (eventDate && eventDate >= normalizedStart && eventDate <= normalizedEnd) {
                    results.push(eventDate);
                }

                current.setMonth(current.getMonth() + 1);
            }

            return results;
        }

        function getMonthParity(date) {
            return ((date.getMonth() + 1) % 2 === 0) ? 'even' : 'odd';
        }

        function getEventDescription(event) {
            // First priority: event-specific description
            if (event.description && event.description.trim()) {
                return event.description;
            }

            // Second priority: tour description via tour_id lookup
            if (event.tour_id && toursLookup[event.tour_id]?.tour_description) {
                return toursLookup[event.tour_id].tour_description;
            }

            return '';
        }

        function resolveEventVenue(event, date) {
            const parity = getMonthParity(date);

            let venue_id = event.venue_id || null;
            let location = null;
            let latlon = null;
            let venue_url = null;

            // Check alternate locations first
            if (event.alternate_locations?.[parity]) {
                venue_id = event.alternate_locations[parity].venue_id || venue_id;
            }

            // Look up venue details from venues collection
            if (venue_id && venuesLookup[venue_id]) {
                const venue = venuesLookup[venue_id];
                location = venue.full_address || venue.name;
                latlon = venue.latlon || null;
                venue_url = venue.url || null;
            }

            return { location, latlon, venue_url };
        }

        function parseExceptionDate(str) {
            let [d, m, y] = str.split('/').map(Number);

            // normalize year (assume 00‚Äì99 means 2000‚Äì2099)
            if (y < 100) y += 2000;

            // JS months are 0-based
            return new Date(y, m - 1, d);
        }


        function createSafePopup(eventData) {
            const container = document.createElement('div');
            container.className = 'popup-content';

            const h3 = document.createElement('h3');
            h3.textContent = eventData.name;
            container.appendChild(h3);

            const dateP = document.createElement('p');
            const dateStrong = document.createElement('strong');
            dateStrong.textContent = formatDate(eventData.date);
            dateP.appendChild(dateStrong);
            container.appendChild(dateP);

            const locationP = document.createElement('p');
            locationP.textContent = eventData.location;
            container.appendChild(locationP);

            if (eventData.performer) {
                const performerP = document.createElement('p');
                const performerEm = document.createElement('em');
                performerEm.textContent = eventData.performer;
                performerP.appendChild(performerEm);
                container.appendChild(performerP);
            }

            return container;
        }

        function createEventData(baseEvent, date, eventType) {
            const { location, latlon, venue_url } = resolveEventVenue(baseEvent, date);

            const eventData = {
                name: baseEvent.name,
                date: date,
                time: baseEvent.time || null,
                location: location,
                latlon: latlon,
                venue_url: venue_url,
                price: baseEvent.price || null,
                isStoryclub: eventType === 'storyclub',
                isSpecial: eventType === 'special',
                isMusic: eventType === 'music',
                isFolk: eventType === 'folk',
                isSession: eventType === 'session'
            };

            // Add type-specific fields
            if (eventType === 'storyclub' || eventType === 'folk' || eventType === 'session') {
                eventData.club = baseEvent.club;
                eventData.facebook = baseEvent.facebook || null;
                eventData.email = baseEvent.email || null;
                eventData.link = baseEvent.link || null;
                eventData.schedule = baseEvent.schedule || null;
                eventData.alternate_locations = baseEvent.alternate_locations || null;
                eventData.exceptions = baseEvent.exceptions || null;

                if (eventType === 'folk') {
                    eventData.storiesWelcome = baseEvent.storiesWelcome || false;
                    eventData.byInvitation = baseEvent.byInvitation || null;
                }
            }

            if (eventType === 'special' || eventType === 'music') {
                eventData.tour_id = baseEvent.tour_id || null;
                eventData.performer_id = baseEvent.performer_id || null;

                // Look up performer details from collection
                const performer_id = baseEvent.performer_id;
                if (performer_id && performersLookup[performer_id]) {
                    eventData.performer = performersLookup[performer_id].name;
                    eventData.performer_url = performersLookup[performer_id].url || null;
                } else {
                    eventData.performer = baseEvent.performer || null;
                    eventData.performer_url = null;
                }
                eventData.description = baseEvent.description || null;
                eventData.event_flyer = baseEvent.event_flyer || null;
                eventData.tour_flyer = baseEvent.tour_flyer || null;
                eventData.fb_event = baseEvent.fb_event || null;
                eventData.ticket_url = baseEvent.ticket_url || null;
            }

            return eventData;
        }

        async function processTourEvents(startDate, endDate) {
            const tours = eventsData.tours || {};

            for (const tourKey in tours) {
                const tour = tours[tourKey];

                // Process both music and special event tours
                // Skip tours that are neither music nor special
                if (!tour.isMusic && !tour.isSpecial) continue;

                // Determine event type
                const eventType = tour.isMusic ? 'music' : 'special';

                // Process each tour date
                for (const tourDate of tour.tour_dates || []) {
                    if (!tourDate.date) {
                        console.warn(`Missing date for tour event in ${tour.name}:`, tourDate);
                        continue;
                    }

                    const dateParts = tourDate.date.split('/');
                    if (dateParts.length !== 3) {
                        console.warn(`Invalid date format for tour event in ${tour.name}:`, tourDate);
                        continue;
                    }

                    const day = parseInt(dateParts[0], 10);
                    const month = parseInt(dateParts[1], 10);
                    const year = parseInt(dateParts[2], 10);

                    const eventDate = new Date(year, month - 1, day);
                    if (eventDate >= startDate && eventDate <= endDate) {
                        // Merge tour-level and date-level properties
                        const mergedEvent = {
                            name: tour.name,
                            tour_id: tourKey,
                            performer_id: tour.performer_id,
                            date: tourDate.date,
                            time: tourDate.time || tour.time || null,
                            price: tourDate.price || tour.price || null,
                            venue_id: tourDate.venue_id,
                            description: tour.tour_description || null,
                            event_flyer: tourDate.event_flyer || null,
                            tour_flyer: tour.tour_flyer || null,
                            fb_event: tourDate.fb_event || null,
                            ticket_url: tourDate.ticket_url || null
                        };

                        const eventData = createEventData(mergedEvent, eventDate, eventType);
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }
        }

        async function processSpecialEvents(events, typ, startDate, endDate) {
            for (const event of events || []) {
                if (!event.date) {
                    console.warn(`Missing date for ${typ} event:`, event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn(`Invalid date format for ${typ} event:`, event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = createEventData(event, eventDate, typ);
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }
        }

        async function processRecurringEvents(events, eventType, startDate, endDate) {
            for (const event of events || []) {
                const exceptions = event.exceptions || [];

                // Parse exception dates
                const exceptionDates = exceptions.map(parseExceptionDate);

                // Expand range to capture context
                let expandedStart = new Date(startDate);
                let expandedEnd = new Date(endDate);

                if (exceptionDates.length > 0) {
                    expandedStart = new Date(Math.min(startDate, ...exceptionDates));
                    expandedStart.setMonth(expandedStart.getMonth() - 1);

                    expandedEnd = new Date(Math.max(endDate, ...exceptionDates));
                    expandedEnd.setMonth(expandedEnd.getMonth() + 1);
                }

                // Get all scheduled dates in expanded range
                const allScheduledDates = parseSchedule(event.schedule, expandedStart, expandedEnd);

                // Build reschedule map: for each exception date, find the regularly scheduled date in that same month
                const rescheduleMap = new Map(); // Key: cancelled date, Value: rescheduled date

                exceptionDates.forEach(excDate => {
                    // Find the regularly scheduled date in the SAME month as the exception
                    const regularDateInSameMonth = allScheduledDates.find(schedDate =>
                        schedDate.getFullYear() === excDate.getFullYear() &&
                        schedDate.getMonth() === excDate.getMonth()
                    );

                    if (regularDateInSameMonth) {
                        // The regular date is cancelled, exception date is the reschedule
                        const cancelKey = `${regularDateInSameMonth.getFullYear()}-${regularDateInSameMonth.getMonth()}-${regularDateInSameMonth.getDate()}`;
                        rescheduleMap.set(cancelKey, excDate);
                    }
                });

                // Process dates in the REQUESTED range
                const dates = parseSchedule(event.schedule, startDate, endDate);

                for (const date of dates) {
                    const { location, latlon, venue_url } = resolveEventVenue(event, date);
                    const eventData = createEventData(event, date, eventType);

                    // Check if THIS specific date was cancelled
                    const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                    const rescheduledTo = rescheduleMap.get(dateKey);

                    if (rescheduledTo) {
                        eventData.isCancelled = true;
                        eventData.rescheduledTo = rescheduledTo;
                        eventData.rescheduledToStr = rescheduledTo.toLocaleDateString('en-GB', {
                            weekday: 'short',
                            day: 'numeric',
                            month: 'short',
                            year: 'numeric'
                        });
                    }

                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }

                // Add rescheduled dates that fall within the current range
                for (const excDate of exceptionDates) {
                    if (excDate >= startDate && excDate <= endDate) {
                        const { location, latlon, venue_url } = resolveEventVenue(event, excDate);
                        const eventData = createEventData(event, excDate, eventType);
                        eventData.isRescheduled = true;

                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }
        }

        async function displayEvents(startDate, endDate) {
            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            allEventsData = [];
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // Process all recurring event types with one function
            await processRecurringEvents(eventsData.events, 'storyclub', startDate, endDate);
            await processRecurringEvents(eventsData.folkNights, 'folk', startDate, endDate);
            await processRecurringEvents(eventsData.irishSessions, 'session', startDate, endDate);

            // Process one-off events (these don't have schedules/exceptions)
            await processSpecialEvents(eventsData.specificEvents, 'special', startDate, endDate);
            await processSpecialEvents(eventsData.musicEvents, 'music', startDate, endDate);

            // Add tour dates
            await processTourEvents(startDate, endDate);

            allEventsData.sort((a, b) => a.date - b.date);
            renderEventsList(allEventsData);
            fitMapToEvents();
        }

        function togglePinMapView() {
            mapViewPinned = document.getElementById('pinMapView').checked;

            if (mapViewPinned) {
                // Save current map view
                pinnedMapView = {
                    center: map.getCenter(),
                    zoom: map.getZoom()
                };
                console.log('Map view pinned:', pinnedMapView);
            } else {
                pinnedMapView = null;
                console.log('Map view unpinned - fitting to current events');
                // When unpinning, immediately fit to current events
                fitMapToEvents();
            }
        }

        function fitMapToEvents() {
            // If map view is pinned, don't auto-zoom
            if (mapViewPinned && pinnedMapView) {
                map.setView(pinnedMapView.center, pinnedMapView.zoom);
                return;
            }

            // Get all events with valid coordinates
            const eventsWithCoords = allEventsData.filter(event => event.coords);

            if (eventsWithCoords.length === 0) {
                // No events with coordinates, zoom to UK
                map.setView([53.0, -2.0], 6);
                return;
            }

            if (eventsWithCoords.length === 1) {
                // Only one event, zoom to it
                const event = eventsWithCoords[0];
                map.setView([event.coords.lat, event.coords.lon], 12);
                return;
            }

            // Multiple events - fit bounds to show all
            const bounds = L.latLngBounds(
                eventsWithCoords.map(event => [event.coords.lat, event.coords.lon])
            );
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        // Color coding: grey for story clubs, green for special events, blue for music
        const EVENT_COLORS = {
            session: '#90ee90',
            folk: '#8b4513',
            music: '#443cd7',
            special: '#4CAF50',
            storyclub: '#808080',
            default: '#808080'
        };

        const EVENT_MARKER_CONFIG = {
            session: { radius: 8, fillOpacity: 0.8 },
            folk: { radius: 8, fillOpacity: 0.8 },
            music: { radius: 8, fillOpacity: 0.8 },
            special: { radius: 8, fillOpacity: 0.8 },
            storyclub: { radius: 8, fillOpacity: 0.7 },
            default: { radius: 5, fillOpacity: 0.8 }
        };

        // Helper function to get event type
        function getEventType(eventData) {
            if (eventData.isSession) return EVENT_TYPES.SESSION;
            if (eventData.isFolk) return EVENT_TYPES.FOLK;
            if (eventData.isMusic) return EVENT_TYPES.MUSIC;
            if (eventData.isSpecial) return EVENT_TYPES.SPECIAL;
            if (eventData.isStoryclub) return EVENT_TYPES.STORYCLUB;
            return 'default';
        }

        function addEventTypeClasses(element, eventData) {
            const type = getEventType(eventData);
            if (type !== 'default') {
                element.classList.add(type);
            }
        }

        async function addMarkerForEvent(eventData) {
            // Check if latlon is provided directly
            let coords;

            // Accept [lat, lon]
            if (Array.isArray(eventData.latlon) && eventData.latlon.length === 2) {
                coords = {
                    lat: eventData.latlon[0],
                    lon: eventData.latlon[1]
                };
            }

            // Accept { lat, lon }
            else if (
                eventData.latlon &&
                typeof eventData.latlon === 'object' &&
                'lat' in eventData.latlon &&
                'lon' in eventData.latlon
            ) {
                coords = {
                    lat: eventData.latlon.lat,
                    lon: eventData.latlon.lon
                };
            }

            else {
                console.warn(`No usable coordinates for event: ${eventData.name} at ${eventData.location}`);
                return;
            }

            if (coords) {
                eventData.coords = coords;

                const eventType = getEventType(eventData);
                const markerColor = EVENT_COLORS[eventType];
                const markerConfig = EVENT_MARKER_CONFIG[eventType];

                const marker = L.circleMarker([coords.lat, coords.lon], {
                    radius: markerConfig.radius,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: markerConfig.fillOpacity
                }).addTo(map);

                marker.bindPopup(createSafePopup(eventData));
                marker.eventData = eventData;

                marker.on('click', () => {
                    highlightEvent(eventData);
                });

                markers.push(marker);
            }
        }

        function updateMapView() {
            // Filter events by map bounds
            const bounds = map.getBounds();
            const visibleEvents = allEventsData.filter(event => {
                // Always show events with "Various" location and no coords
                if (!event.coords && event.location && event.location.startsWith('Various')) {
                    return true;
                }
                if (!event.coords) return false;
                return bounds.contains([event.coords.lat, event.coords.lon]);
            });

            console.log(`Events in map view: ${visibleEvents.length} of ${allEventsData.length}`);
            renderEventsList(visibleEvents);
        }

        function toggleEventExpandable(eventId, event) {
            event.stopPropagation(); // Prevent map zoom when clicking the button
            const expandable = document.getElementById(eventId);
            if (expandable) {
                if (expandable.style.display === 'none') {
                    expandable.style.display = 'block';
                } else {
                    expandable.style.display = 'none';
                }
            }
        }

        const ICON_SVG = {
            website: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>',
            email: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>',
            facebook: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>'
        }

        function createIcon(iconsContainer, typ, url) {
            if (url) {
                const safeurl = sanitizeUrl(url);

                if (safeurl) {
                    const link = document.createElement('a');
                    link.href = safeurl;
                    link.target = '_blank';
                    link.className = `event-${typ}`;
                    link.title = String(typ).charAt(0).toUpperCase() + String(typ).slice(1);;
                    link.onclick = (e) => e.stopPropagation();
                    link.innerHTML = ICON_SVG[typ];
                    iconsContainer.appendChild(link);
                }
            }
        }

        function createEventElement(event) {
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event';
            addEventTypeClasses(eventDiv, event);

            // Add type classes
            addEventTypeClasses(eventDiv, event);

            // Add click handler
            if (event.coords?.lat && event.coords?.lon) {
                eventDiv.onclick = () => zoomToEvent(event.coords.lat, event.coords.lon);
            }

            eventDiv.setAttribute('data-event-id', `${escapeHtml(event.name)}-${event.date.getTime()}`);

            // Build event content
            eventDiv.appendChild(createEventHeader(event));

            if (event.performer) {
                eventDiv.appendChild(createPerformerSection(event));
            }

            if (event.location) {
                eventDiv.appendChild(createLocationSection(event));
            }

            eventDiv.appendChild(createDateSection(event));

            const ticketsSection = createTicketsSection(event);
            if (ticketsSection) {
                eventDiv.appendChild(ticketsSection);
            }

            const expandable = createExpandableSection(event);
            if (expandable) {
                eventDiv.appendChild(expandable);
            }

            return eventDiv;
        }

        function createEventHeader(event) {
            const header = document.createElement('div');
            header.className = 'event-name';
            header.appendChild(document.createTextNode(event.name));

            // Add badges
            if (event.isFolk && event.storiesWelcome) {
                header.appendChild(document.createTextNode(' '));
                header.appendChild(createBadge('üìñ Stories Welcome'));
            }

            if (event.isFolk && event.byInvitation) {
                header.appendChild(document.createTextNode(' '));
                header.appendChild(createBadge('By Invitation'));
            }

            // Add icons
            header.appendChild(createIconsContainer(event));

            return header;
        }

        function createBadge(text) {
            const badge = document.createElement('span');
            badge.className = 'event-badge';
            badge.textContent = text;
            return badge;
        }

        function createIconsContainer(event) {
            const container = document.createElement('span');

            if (event.link) {
                createIcon(container, 'website', event.link);
            }

            if (event.email) {
                createIcon(container, 'email', `mailto:${event.email}`);
            }

            if (event.facebook) {
                const fbUrl = event.facebook.startsWith('http')
                    ? event.facebook
                    : `https://facebook.com/${event.facebook}`;
                createIcon(container, 'facebook', fbUrl);
            }

            return container;
        }

        function createPerformerSection(event) {
            const performerDiv = document.createElement('div');
            performerDiv.style.fontStyle = 'italic';

            if (event.performer_url) {
                const safePerformerUrl = sanitizeUrl(event.performer_url);
                if (safePerformerUrl) {
                    const performerLink = document.createElement('a');
                    performerLink.href = safePerformerUrl;
                    performerLink.target = '_blank';
                    performerLink.style.color = 'inherit';
                    performerLink.style.textDecoration = 'none';
                    performerLink.onclick = (e) => e.stopPropagation();

                    const performerStrong = document.createElement('strong');
                    performerStrong.textContent = event.performer;
                    performerLink.appendChild(performerStrong);

                    performerDiv.appendChild(performerLink);
                } else {
                    performerDiv.textContent = event.performer;
                }
            } else {
                performerDiv.textContent = event.performer;
            }

            return performerDiv;
        }

        function createLocationSection(event) {
            const locationDiv = document.createElement('div');
            locationDiv.className = 'event-location';

            if (event.venue_url) {
                const safeVenueUrl = sanitizeUrl(event.venue_url);
                if (safeVenueUrl) {
                    const commaIndex = event.location.indexOf(',');
                    const venueName = commaIndex > 0 ? event.location.substring(0, commaIndex) : event.location;
                    const restOfLocation = commaIndex > 0 ? event.location.substring(commaIndex) : '';

                    const venueLink = document.createElement('a');
                    venueLink.href = safeVenueUrl;
                    venueLink.target = '_blank';
                    venueLink.className = 'venue-link';

                    const venueStrong = document.createElement('strong');
                    venueStrong.textContent = venueName;
                    venueLink.appendChild(venueStrong);

                    locationDiv.appendChild(venueLink);
                    locationDiv.appendChild(document.createTextNode(restOfLocation));
                } else {
                    locationDiv.textContent = event.location;
                }
            } else {
                locationDiv.textContent = event.location;
            }

            return locationDiv;
        }

        function createDateSection(event) {
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const dateDiv = document.createElement('div');
            dateDiv.className = 'event-date';

            const dayName = daysOfWeek[event.date.getDay()];
            const day = event.date.getDate();
            const month = months[event.date.getMonth()];
            const year = event.date.getFullYear();
            const scheduleText = event.schedule ? ` (${event.schedule})` : '';

            let dateText = `${dayName}, ${day} ${month} ${year}`;
            if (!event.isRescheduled) {
                dateText += scheduleText;
            }

            if (event.isCancelled) {
                const cancelledSpan = document.createElement('span');
                cancelledSpan.className = 'event-date-cancelled';
                cancelledSpan.textContent = `${dayName}, ${day} ${month} ${year} ${scheduleText}`;
                dateDiv.appendChild(cancelledSpan);

                if (event.rescheduledTo) {
                    const rescheduledSpan = document.createElement('span');
                    rescheduledSpan.className = 'event-date-rescheduled-notice';
                    rescheduledSpan.textContent = ` (Rescheduled to ${event.rescheduledToStr})`;
                    dateDiv.appendChild(rescheduledSpan);
                }
            } else {
                dateDiv.appendChild(document.createTextNode(dateText));

                if (event.isRescheduled) {
                    const usuallySpan = document.createElement('span');
                    usuallySpan.className = 'event-date-usually';
                    usuallySpan.textContent = ` (usually ${event.schedule})`;
                    dateDiv.appendChild(usuallySpan);
                }
            }

            // Add time and price
            if (event.time) {
                dateDiv.appendChild(document.createTextNode(` ‚Ä¢ ${event.time}`));
            }
            if (event.price) {
                dateDiv.appendChild(document.createTextNode(` ‚Ä¢ ${event.price}`));
            }

            return dateDiv;
        }

        function createTicketsSection(event) {
            if (!event.isSpecial && !event.isMusic) {
                return null;
            }

            const ticketsDiv = document.createElement('div');
            ticketsDiv.className = 'event-tickets';

            if (event.ticket_url) {
                const safeTicketUrl = sanitizeUrl(event.ticket_url);
                if (safeTicketUrl) {
                    const ticketLink = document.createElement('a');
                    ticketLink.href = safeTicketUrl;
                    ticketLink.target = '_blank';
                    ticketLink.textContent = 'Tickets available here';
                    ticketsDiv.appendChild(ticketLink);
                }
            }

            if (event.fb_event) {
                if (event.ticket_url) {
                    const separator = document.createElement('span');
                    separator.className = 'separator';
                    separator.textContent = '|';
                    ticketsDiv.appendChild(separator);
                }

                const fbEventUrl = sanitizeUrl(`https://www.facebook.com/events/${event.fb_event}`);
                if (fbEventUrl) {
                    const fbLink = document.createElement('a');
                    fbLink.href = fbEventUrl;
                    fbLink.target = '_blank';
                    fbLink.className = 'event-facebook-inline';
                    fbLink.title = 'Facebook Event';
                    fbLink.onclick = (e) => e.stopPropagation();
                    fbLink.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>';
                    ticketsDiv.appendChild(fbLink);
                }
            }

            return ticketsDiv.children.length > 0 ? ticketsDiv : null;
        }

        function getExpandableContent(event) {
            // Get description using the proper lookup function
            const description = getEventDescription(event);

            const flyers = [];

            // Add event flyer if available
            if (event.event_flyer && event.event_flyer.trim()) {
                flyers.push({
                    path: event.event_flyer,
                    altSuffix: 'event flyer'
                });
            }

            // Add tour flyer - check event first, then tour lookup
            let tourFlyer = event.tour_flyer;
            if (!tourFlyer && event.tour_id && toursLookup[event.tour_id]) {
                tourFlyer = toursLookup[event.tour_id].tour_flyer;
            }

            if (tourFlyer && tourFlyer.trim()) {
                flyers.push({
                    path: tourFlyer,
                    altSuffix: 'tour flyer'
                });
            }

            return {
                hasDescription: Boolean(description?.trim()),
                hasFlyers: flyers.length > 0,
                description,
                flyers
            };
        }

        function createExpandableSection(event) {
            const { hasDescription, hasFlyers, description, flyers } = getExpandableContent(event);

            // Check if performer has a bio
            const performer_id = event.performer_id;
            const hasBio = performer_id && performersLookup[performer_id]?.bio;

            // Return null if no expandable content at all
            if (!hasDescription && !hasFlyers && !hasBio) {
                return null;
            }

            const container = document.createElement('div');

            // Create unique IDs for this event's expandables
            const bioExpandableId = `event-bio-${Math.random().toString(36).substr(2, 9)}`;
            const infoExpandableId = `event-info-${Math.random().toString(36).substr(2, 9)}`;
            const flyersExpandableId = `event-flyers-${Math.random().toString(36).substr(2, 9)}`;

            // Helper function to toggle expandables (close others)
            const toggleExpandable = (targetId) => {
                const bioDiv = document.getElementById(bioExpandableId);
                const infoDiv = document.getElementById(infoExpandableId);
                const flyersDiv = document.getElementById(flyersExpandableId);

                if (targetId === bioExpandableId) {
                    const isCurrentlyOpen = bioDiv.style.display === 'block';
                    bioDiv.style.display = isCurrentlyOpen ? 'none' : 'block';
                    if (infoDiv) infoDiv.style.display = 'none';
                    if (flyersDiv) flyersDiv.style.display = 'none';
                } else if (targetId === infoExpandableId) {
                    const isCurrentlyOpen = infoDiv.style.display === 'block';
                    infoDiv.style.display = isCurrentlyOpen ? 'none' : 'block';
                    if (bioDiv) bioDiv.style.display = 'none';
                    if (flyersDiv) flyersDiv.style.display = 'none';
                } else if (targetId === flyersExpandableId) {
                    const isCurrentlyOpen = flyersDiv.style.display === 'block';
                    flyersDiv.style.display = isCurrentlyOpen ? 'none' : 'block';
                    if (bioDiv) bioDiv.style.display = 'none';
                    if (infoDiv) infoDiv.style.display = 'none';
                }
            };

            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '10px';
            buttonContainer.style.marginTop = '12px';

            // More info button (only if description exists)
            if (hasDescription) {
                const expandBtn = document.createElement('div');
                expandBtn.className = 'event-expand-btn';
                expandBtn.textContent = 'More info...';
                expandBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleExpandable(infoExpandableId);
                };
                buttonContainer.appendChild(expandBtn);
            }

            // Flyer(s) button (only if flyers exist)
            if (hasFlyers) {
                const flyersBtn = document.createElement('div');
                flyersBtn.className = 'event-expand-btn';
                flyersBtn.textContent = flyers.length > 1 ? 'Flyers' : 'Flyer';
                flyersBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleExpandable(flyersExpandableId);
                };
                buttonContainer.appendChild(flyersBtn);
            }

            // Bio button (if bio exists)
            if (hasBio) {
                const bioBtn = document.createElement('div');
                bioBtn.className = 'event-expand-btn';
                bioBtn.textContent = 'Bio';
                bioBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleExpandable(bioExpandableId);
                };
                buttonContainer.appendChild(bioBtn);
            }

            container.appendChild(buttonContainer);

            // Create bio expandable content
            if (hasBio) {
                const bioExpandableDiv = document.createElement('div');
                bioExpandableDiv.className = 'event-expandable';
                bioExpandableDiv.id = bioExpandableId;
                bioExpandableDiv.style.display = 'none';

                const bioDiv = document.createElement('div');
                bioDiv.className = 'event-description';

                const bio = performersLookup[performer_id].bio;
                const paragraphs = bio.split('\n\n\n\n');
                paragraphs.forEach(p => {
                    if (p.trim()) {
                        const pElem = document.createElement('p');
                        pElem.textContent = p.replace(/\n\n/g, '\n');
                        bioDiv.appendChild(pElem);
                    }
                });

                bioExpandableDiv.appendChild(bioDiv);
                container.appendChild(bioExpandableDiv);
            }

            // Create info expandable content (description only)
            if (hasDescription) {
                const expandableDiv = document.createElement('div');
                expandableDiv.className = 'event-expandable';
                expandableDiv.id = infoExpandableId;
                expandableDiv.style.display = 'none';

                const descDiv = document.createElement('div');
                descDiv.className = 'event-description';

                const paragraphs = description.split('\n\n\n\n');
                paragraphs.forEach(p => {
                    if (p.trim()) {
                        const pElem = document.createElement('p');
                        pElem.textContent = p.replace(/\n\n/g, '\n');
                        descDiv.appendChild(pElem);
                    }
                });

                expandableDiv.appendChild(descDiv);
                container.appendChild(expandableDiv);
            }

            // Create flyers expandable content (flyers only)
            if (hasFlyers) {
                const flyersExpandableDiv = document.createElement('div');
                flyersExpandableDiv.className = 'event-expandable';
                flyersExpandableDiv.id = flyersExpandableId;
                flyersExpandableDiv.style.display = 'none';

                flyers.forEach((flyer, index) => {
                    if (flyer.path) {
                        const img = document.createElement('img');
                        img.alt = `${event.name} ${flyer.altSuffix}`;
                        const flyerPath = flyer.path.replace(/[^a-zA-Z0-9._-]/g, '');
                        img.src = `./storyclub_assets/event_flyers/${flyerPath}`;
                        img.className = 'event-flyer-image';
                        if (index > 0) {
                            img.style.marginTop = '15px';
                        }
                        flyersExpandableDiv.appendChild(img);
                    }
                });

                container.appendChild(flyersExpandableDiv);
            }

            return container;
        }

        function renderEventsList(eventsToShow) {
            const eventsList = document.getElementById('eventsList');

            if (eventsToShow.length === 0) {
                eventsList.innerHTML = '<div class="no-events">No events in this view</div>';
                return;
            }

            console.log(`Rendering ${eventsToShow.length} events`);
            eventsList.innerHTML = '';

            eventsToShow.forEach(event => {
                eventsList.appendChild(createEventElement(event));
            });

            filterEvents();
        }

        function zoomToEvent(lat, lon) {
            if (lat && lon) {
                map.setView([lat, lon], 13);
            }
        }

        function highlightEvent(eventData) {
            const eventId = `${eventData.name}-${eventData.date.getTime()}`;
            document.querySelectorAll('.event').forEach(el => el.classList.remove('highlighted'));
            const eventEl = document.querySelector(`[data-event-id="${eventId}"]`);
            if (eventEl) {
                eventEl.classList.add('highlighted');
                eventEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function formatDate(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${days[date.getDay()]}, ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function shouldShowEvent(eventData, filters) {
            const { storyclubsOn, specialOn, showMusic, showFolk, showSessions } = filters;

            if (storyclubsOn && eventData.isStoryclub) return true;
            if (specialOn && eventData.isSpecial) return true;
            if (showMusic && eventData.isMusic) return true;
            if (showFolk && eventData.isFolk) return true;
            if (showSessions && eventData.isSession) return true;

            return false;
        }

        function filterEvents() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const filters = {
                storyclubsOn: document.getElementById('storyclubsOn').checked,
                specialOn: document.getElementById('specialOn').checked,
                showMusic: document.getElementById('showMusic').checked,
                showFolk: document.getElementById('showFolk').checked,
                showSessions: document.getElementById('showSessions').checked
            };

            // Filter event list items
            document.querySelectorAll('.event').forEach(event => {
                const isStoryclub = event.classList.contains('storyclub');
                const isSpecial = event.classList.contains('special');
                const isMusic = event.classList.contains('music');
                const isFolk = event.classList.contains('folk');
                const isSession = event.classList.contains('session');

                const eventData = { isStoryclub, isSpecial, isMusic, isFolk, isSession };
                let visible = shouldShowEvent(eventData, filters);

                if (visible && searchTerm) {
                    visible = event.textContent.toLowerCase().includes(searchTerm);
                }

                event.classList.toggle('hidden', !visible);
            });

            // Filter map markers
            markers.forEach(marker => {
                let visible = shouldShowEvent(marker.eventData, filters);

                if (visible && searchTerm) {
                    const searchableText = `${marker.eventData.name} ${marker.eventData.location} ${marker.eventData.performer || ''}`.toLowerCase();
                    visible = searchableText.includes(searchTerm);
                }

                if (visible) {
                    marker.setStyle({ opacity: 1, fillOpacity: 0.8 });
                } else {
                    marker.setStyle({ opacity: 0, fillOpacity: 0 });
                }
            });

            const visibleCount = document.querySelectorAll('.event:not(.hidden)').length;
            console.log(`Visible events after filtering: ${visibleCount}`);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';

            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput) {
                const startDate = new Date(startInput);
                const endDate = endInput
                    ? new Date(endInput)
                    : getWeekEnd(getWeekStart(startDate));

                // Re-run date-based display
                displayEvents(startDate, endDate);

                // Clear active week buttons (optional UX choice)
                document.querySelectorAll('.button-group button')
                    .forEach(btn => btn.classList.remove('active'));
            } else {
                // Fallback (should rarely happen)
                filterEvents();
            }
        }

        async function searchAllUpcoming() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();

            if (!searchTerm) {
                alert('Please enter a search term first');
                return;
            }

            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Search 2 years into the future
            const futureDate = new Date(today);
            futureDate.setFullYear(futureDate.getFullYear() + 2);

            // Clear the list and markers
            allEventsData = [];
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // The checkboxes will filter visibility after loading

            // Search recurring story club events (load regardless of checkbox)
            for (const event of eventsData.events || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    // Find the next occurrence of this recurring event
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        // Just show the first (next) occurrence
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = createEventData(event, nextDate, 'storyclub');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search specific events (story shows)
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const searchableText = `${event.name} ${event.location} ${event.performer || ''}`.toLowerCase();

                    if (searchableText.includes(searchTerm)) {
                        const eventData = createEventData(event, eventDate, 'special');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search music events
            for (const event of eventsData.musicEvents || []) {
                if (!event.date) continue;

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) continue;

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= today && eventDate <= futureDate) {
                    const searchableText = `${event.name} ${event.location} ${event.performer || ''}`.toLowerCase();

                    if (searchableText.includes(searchTerm)) {
                        const eventData = createEventData(event, eventDate, 'music');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search tour events (music tours)
            // Search tour events (music tours)
            const tours = eventsData.tours || {};
            for (const tourKey in tours) {
                const tour = tours[tourKey];

                // Skip tours that are neither music nor special
                if (!tour.isMusic && !tour.isSpecial) continue;

                // Determine event type (same as processTourEvents)
                const eventType = tour.isMusic ? 'music' : 'special';

                // Get performer name if available
                let performerName = '';
                if (tour.performer_id && performersLookup[tour.performer_id]) {
                    performerName = performersLookup[tour.performer_id].name;
                }

                // Build tour-level searchable text
                const tourSearchText = `${tour.name} ${tour.tour_name || ''} ${performerName} ${tour.tour_description || ''}`.toLowerCase();

                for (const tourDate of tour.tour_dates || []) {
                    if (!tourDate.date) continue;

                    const dateParts = tourDate.date.split('/');
                    if (dateParts.length !== 3) continue;

                    const day = parseInt(dateParts[0], 10);
                    const month = parseInt(dateParts[1], 10);
                    const year = parseInt(dateParts[2], 10);

                    const eventDate = new Date(year, month - 1, day);
                    if (eventDate >= today && eventDate <= futureDate) {
                        // Get venue info for this specific date
                        const venue_id = tourDate.venue_id;
                        let venueName = '';
                        let venueLocation = '';
                        if (venue_id && venuesLookup[venue_id]) {
                            venueName = venuesLookup[venue_id].name || '';
                            venueLocation = venuesLookup[venue_id].full_address || '';
                        }

                        // Build complete searchable text
                        const fullSearchText = `${tourSearchText} ${venueName} ${venueLocation} ${tourDate.time || ''} ${tourDate.price || ''}`.toLowerCase();

                        if (fullSearchText.includes(searchTerm)) {
                            const mergedEvent = {
                                name: tour.name,
                                tour_id: tourKey,
                                performer_id: tour.performer_id,
                                date: tourDate.date,
                                time: tourDate.time || tour.time || null,
                                price: tourDate.price || tour.price || null,
                                venue_id: tourDate.venue_id,
                                description: tour.tour_description || null,
                                event_flyer: tourDate.event_flyer || null,
                                tour_flyer: tour.tour_flyer || null,
                                fb_event: tourDate.fb_event || null,
                                ticket_url: tourDate.ticket_url || null
                            };

                            const eventData = createEventData(mergedEvent, eventDate, eventType);
                            allEventsData.push(eventData);
                            await addMarkerForEvent(eventData);
                            // REMOVED: break; // <-- This was stopping after first match
                        }
                    }
                }
            }

            // Search folk nights
            for (const event of eventsData.folkNights || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = createEventData(event, nextDate, 'folk');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            // Search Irish sessions
            for (const event of eventsData.irishSessions || []) {
                const searchableText = `${event.name} ${event.location} ${event.club || ''}`.toLowerCase();
                if (searchableText.includes(searchTerm)) {
                    const dates = parseSchedule(event.schedule, today, futureDate);
                    if (dates.length > 0) {
                        const nextDate = dates[0];
                        const { location, latlon, venue_url } = resolveEventVenue(event, nextDate);
                        const eventData = createEventData(event, nextDate, 'session');
                        allEventsData.push(eventData);
                        await addMarkerForEvent(eventData);
                    }
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);

            // Update the date inputs to reflect the search range
            updateDateInputs(today, futureDate);

            // Clear any active week button
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));

            renderEventsList(allEventsData);
            fitMapToEvents();

            if (allEventsData.length === 0) {
                const eventsList = document.getElementById('eventsList');
                eventsList.innerHTML = `<div class="no-events">No upcoming events found matching "${searchTerm}"</div>`;
            }
        }
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function getWeekEnd(weekStart) {
            const end = new Date(weekStart);
            end.setDate(end.getDate() + 6);
            return end;
        }

        function setActiveMode(mode) {
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            if (mode === 'thisWeek') document.getElementById('thisWeekBtn').classList.add('active');
            else if (mode === 'nextWeek1') document.getElementById('nextWeekBtn').classList.add('active');
            else if (mode === 'nextWeek2') document.getElementById('afterThatWeekBtn').classList.add('active');
            else if (mode === 'nextWeek3') document.getElementById('andAnotherWeekBtn').classList.add('active');
            else if (mode === 'lastWeek1') document.getElementById('lastWeekBtn').classList.add('active');
        }

        function updateDateInputs(startDate, endDate) {
            // Format dates as YYYY-MM-DD for the date inputs
            const formatForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            document.getElementById('startDate').value = formatForInput(startDate);
            document.getElementById('endDate').value = formatForInput(endDate);
        }

        function showThisWeek() {
            const today = new Date();
            const weekStart = getWeekStart(today);
            const weekEnd = getWeekEnd(weekStart);
            updateDateInputs(weekStart, weekEnd);
            displayEvents(weekStart, weekEnd);
            setActiveMode('thisWeek');
        }

        function showWeek(weeksAhead = 1) {
            const today = new Date();
            const thisWeekStart = getWeekStart(today);
            const targetWeekStart = new Date(thisWeekStart);
            targetWeekStart.setDate(targetWeekStart.getDate() + (7 * weeksAhead));
            const targetWeekEnd = getWeekEnd(targetWeekStart);
            updateDateInputs(targetWeekStart, targetWeekEnd);
            displayEvents(targetWeekStart, targetWeekEnd);
            setActiveMode(weeksAhead > 0 ? `nextWeek${weeksAhead}` : `lastWeek${Math.abs(weeksAhead)}`);
        }

        function showDateRange(clearActiveButton = true) {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select at least a start date');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));
            displayEvents(startDate, endDate);

            // Only clear active button styling when manually using custom date range
            if (clearActiveButton) {
                document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            }
        }
        let lastStartDate = '';
        let lastEndDate = '';

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function handleStartDateChange() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput && endInput) {
                const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
                const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

                const startDate = new Date(startYear, startMonth - 1, startDay);
                const endDate = new Date(endYear, endMonth - 1, endDay);

                // Start date changed - if it's now after end date, adjust end to end of start's week
                if (startDate > endDate) {
                    const weekEnd = getWeekEnd(getWeekStart(startDate));
                    document.getElementById('endDate').value = formatDateForInput(weekEnd);
                }
            }

            if (startInput) {
                showDateRange(true);
            }
        }

        function handleEndDateChange() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (startInput && endInput) {
                const [startYear, startMonth, startDay] = startInput.split('-').map(Number);
                const [endYear, endMonth, endDay] = endInput.split('-').map(Number);

                const startDate = new Date(startYear, startMonth - 1, startDay);
                const endDate = new Date(endYear, endMonth - 1, endDay);

                // End date changed - if it's now before start date, adjust start to beginning of end's week
                if (endDate < startDate) {
                    const weekStart = getWeekStart(endDate);
                    document.getElementById('startDate').value = formatDateForInput(weekStart);
                }
            }

            if (startInput) {
                showDateRange(true);
            }
        }

        function generateShareableURL(startDate, endDate) {
            const formatForInput = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            const params = new URLSearchParams();
            params.set('start', formatForInput(startDate));
            params.set('end', formatForInput(endDate));

            // Add filter states
            params.set('storyclubs', document.getElementById('storyclubsOn').checked ? '1' : '0');
            params.set('special', document.getElementById('specialOn').checked ? '1' : '0');
            params.set('music', document.getElementById('showMusic').checked ? '1' : '0');
            params.set('folk', document.getElementById('showFolk').checked ? '1' : '0');
            params.set('sessions', document.getElementById('showSessions').checked ? '1' : '0');

            const center = map.getCenter();
            const lat = center.lat;
            const lng = center.lng;
            const zoom = map.getZoom();
            params.set('lat', lat);
            params.set('lng', lng);
            params.set('zoom', zoom);
            params.set('pinmap', document.getElementById('pinMapView').checked ? '1' : '0');

            const searchTerm = document.getElementById('searchInput').value.trim();
            if (searchTerm) {
                params.set('q', searchTerm);
            }

            return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
        }

        async function copyShareableLink() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select a date range first');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));

            const shareableURL = generateShareableURL(startDate, endDate);

            try {
                await navigator.clipboard.writeText(shareableURL);
                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const tempInput = document.createElement('input');
                tempInput.value = shareableURL;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const feedback = document.getElementById('copyFeedback');
                feedback.style.display = 'inline';
                setTimeout(() => {
                    feedback.style.display = 'none';
                }, 2000);
            }
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const start = params.get('start');
            const end = params.get('end');

            if (start) {
                const storyclubs = params.get('storyclubs') === '1';
                const special = params.get('special') === '1';
                const music = params.get('music') === '1';
                const folk = params.get('folk') === '1';
                const sessions = params.get('sessions') === '1';
                const pinmap = params.get('pinmap') === '1';
                const zoom = params.get('zoom') ? parseInt(params.get('zoom'), 10) : 6;;
                const lat = params.get('lat') ? parseFloat(params.get('lat')) : 53.0;
                const lng = params.get('lng') ? parseFloat(params.get('lng')) : 0.0;
                // If none are selected, default storyclubs and special to true
                const noneSelected = !storyclubs && !special && !music && !folk && !sessions;

                const q = params.get('q');

                return {
                    startDate: new Date(start),
                    endDate: end ? new Date(end) : null,
                    storyclubs: noneSelected ? true : storyclubs,
                    special: noneSelected ? true : special,
                    folk: noneSelected ? true : folk,
                    sessions: noneSelected ? true : sessions,
                    music: music,
                    pinmap: pinmap,
                    lat: lat,
                    lng: lng,
                    zoom: zoom,
                    searchTerm: q
                };
            }
            return null;
        }


        function toggleTabContent(tabId) {
            const allTabs = document.querySelectorAll('.tab-content-area');
            const clickedTab = document.getElementById(tabId);
            const allButtons = document.querySelectorAll('.header-tab-button');

            // If clicking the already-open tab, close it
            if (clickedTab.style.display === 'block') {
                clickedTab.style.display = 'none';
                event.target.classList.remove('active');
            } else {
                // Close all tabs
                allTabs.forEach(tab => tab.style.display = 'none');
                allButtons.forEach(btn => btn.classList.remove('active'));

                // Open clicked tab
                clickedTab.style.display = 'block';
                event.target.classList.add('active');
            }
        }

        // Initialize
        window.addEventListener('load', async () => {
            await loadEventsData();
            initMap();

            // Check for URL parameters first
            const urlParams = getURLParams();
            if (urlParams) {
                const startDate = urlParams.startDate;
                const endDate = urlParams.endDate || getWeekEnd(getWeekStart(startDate));

                document.getElementById('storyclubsOn').checked = urlParams.storyclubs;
                document.getElementById('specialOn').checked = urlParams.special;
                document.getElementById('showMusic').checked = urlParams.music;
                document.getElementById('showFolk').checked = urlParams.folk;
                document.getElementById('showSessions').checked = urlParams.sessions;

                updateDateInputs(startDate, endDate);

                document.getElementById('pinMapView').checked = urlParams.pinmap;
                console.log("pinmap", urlParams, urlParams.pinmap)
                mapViewPinned = urlParams.pinmap;

                // Apply specific map view if provided
                if (urlParams.lat && urlParams.lng && urlParams.zoom) {
                    map.setView([urlParams.lat, urlParams.lng], urlParams.zoom);
                    if (mapViewPinned) {
                        pinnedMapView = {
                            center: [urlParams.lat, urlParams.lng],
                            zoom: urlParams.zoom
                        };
                    }
                }

                //  restore search term
                if (urlParams.searchTerm) {
                    document.getElementById('searchInput').value = urlParams.searchTerm;

                    // Behave exactly like "Search All Upcoming"
                    await searchAllUpcoming();
                } else {
                    await displayEvents(startDate, endDate);
                }
            } else {
                showThisWeek();
            }
        });

    </script>
</body>

</html>