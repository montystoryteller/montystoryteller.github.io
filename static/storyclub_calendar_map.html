<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storytelling Events with Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            color: #333;
            text-align: center;
            margin: 5px 0 10px 0;
        }

        h2 {
            text-align: center;
            font-style: italic;
            color: #898b89;
            margin: 5px 0 20px 0;
            font-size: 18px;
        }

        .layout-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .layout-container {
                grid-template-columns: 1fr;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            grid-column: 1 / -1;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.active {
            background-color: #2e7d32;
            box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.3);
        }

        .date-inputs {
            display: grid;
            grid-template-columns: auto 1fr auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        input[type="date"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            transition: all 0.3s;
        }

        #map-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            height: 600px;
        }

        #map {
            height: 100%;
            border-radius: 4px;
        }

        .events-list {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .event {
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .event:hover {
            background-color: #f0f0f0;
        }

        .event.special {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%);
            border: 2px solid #2e7d32;
            color: white;
        }

        .event.music {
            background: linear-gradient(135deg, #443cd7 0%, #8e9df3 100%);
            border: 2px solid #1006c6;
            color: white;
        }

        .event.highlighted {
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            border-left-width: 8px;
        }

        .event-name {
            font-weight: bold;
            font-size: 16px;
        }

        .event-date {
            margin-top: 5px;
        }

        .event-location {
            font-style: italic;
            margin-top: 3px;
            font-size: 14px;
        }

        .event.hidden {
            display: none;
        }

        .search-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .search-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        #searchInput {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .no-events {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .leaflet-popup-content {
            margin: 10px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #2e7d32;
        }

        .popup-content p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            button {
                padding: 8px 6px;
                font-size: 11px;
            }

            .date-inputs {
                grid-template-columns: auto 1fr;
                gap: 8px;
            }
        }
    </style>
</head>

<body>
    <h1>The New Troubadours — Storytelling, Music and Punk Poet Events Calendar (UK)</h1>
    <h2>Appropriate all ages, aimed at adults.</h2>

    <div class="controls">
        <div class="button-group">
            <button id="lastWeekBtn" onclick="showWeek(-1)">Last Week</button>
            <button id="thisWeekBtn" onclick="showThisWeek()">This Week</button>
            <button id="nextWeekBtn" onclick="showWeek()">Next Week</button>
            <button id="afterThatWeekBtn" onclick="showWeek(2)">Week After</button>
            <button id="andAnotherWeekBtn" onclick="showWeek(3)">And Another</button>
        </div>
        <div class="date-inputs">
            <label>From:</label>
            <input type="date" id="startDate" onchange="handleDateChange()">
            <label>To:</label>
            <input type="date" id="endDate" onchange="handleDateChange()">
            <button id="showBtn" onclick="showDateRange()">Show Events</button>
        </div>

        <div class="search-controls">
            <div class="search-row">
                <input type="text" id="searchInput" placeholder="Search events..." onkeyup="filterEvents()">
                <button onclick="clearSearch()">Clear</button>
            </div>
            <div class="filter-row">
                <label>
                    <input type="checkbox" checked id="storyclubsOn" onchange="filterEvents()">
                    Story clubs
                </label>
                <label>
                    <input type="checkbox" checked id="specialOn" onchange="filterEvents()">
                    Story shows
                </label>
                <label>
                    <input type="checkbox" id="showMusic" onchange="filterEvents()">
                    Music events
                </label>
            </div>
        </div>
    </div>

    <div class="layout-container">
        <div id="map-container">
            <div id="map"></div>
        </div>
        <div class="events-list" id="eventsList"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        let map;
        let markers = [];
        let allEventsData = [];
        const geocodeCache = {};
        let geocodeQueue = [];
        let isGeocoding = false;
        let externalGeocodeCache = null;
        let eventsData = null;

        // Load events from JSON file
        async function loadEventsData() {
            try {
                const response = await fetch('events_combined.json');
                if (response.ok) {
                    eventsData = await response.json();
                    console.log(`✓ Loaded events from JSON:`);
                    console.log(`  - ${eventsData.events?.length || 0} recurring events`);
                    console.log(`  - ${eventsData.specificEvents?.length || 0} specific events`);
                    console.log(`  - ${eventsData.musicEvents?.length || 0} music events`);

                    // Flag events with missing geocode
                    const checkMissing = (eventsList, label) => {
                        const missing = eventsList?.filter(e => e.geocode_missing) || [];
                        if (missing.length > 0) {
                            console.warn(`⚠ ${missing.length} ${label} missing geocode data:`);
                            missing.forEach(e => console.warn(`  - ${e.name}: ${e.location}`));
                        }
                    };

                    checkMissing(eventsData.events, 'recurring events');
                    checkMissing(eventsData.specificEvents, 'specific events');
                    checkMissing(eventsData.musicEvents, 'music events');

                    return eventsData;
                } else {
                    console.error('Failed to load events_combined.json');
                    return null;
                }
            } catch (error) {
                console.error('Error loading events:', error);
                return null;
            }
        }

        // Load external geocode cache
        async function loadExternalGeocodeCache() {
            try {
                const response = await fetch('geocode_cache.json');
                if (response.ok) {
                    externalGeocodeCache = await response.json();
                    console.log(`✓ Loaded ${Object.keys(externalGeocodeCache).length} cached locations from geocode_cache.json`);

                    // Convert to internal format
                    for (const [location, coords] of Object.entries(externalGeocodeCache)) {
                        if (coords && coords.lat && coords.lon) {
                            geocodeCache[location] = { lat: coords.lat, lon: coords.lon };
                        } else {
                            geocodeCache[location] = null;
                        }
                    }
                }
            } catch (error) {
                console.log('No geocode_cache.json found, will use API geocoding');
            }
        }

        function initMap() {
            map = L.map('map').setView([53.0, -2.0], 6); // Center on UK

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            map.on('moveend', updateMapView);
        }

        // Rate-limited geocoding function
        async function geocodeLocation(location) {
            if (geocodeCache[location]) {
                return geocodeCache[location];
            }

            // Add to queue and process
            return new Promise((resolve) => {
                geocodeQueue.push({ location, resolve });
                processGeocodeQueue();
            });
        }

        async function processGeocodeQueue() {
            if (isGeocoding || geocodeQueue.length === 0) return;

            isGeocoding = true;
            const { location, resolve } = geocodeQueue.shift();

            try {
                // Add delay to respect rate limits (1 request per second)
                await new Promise(r => setTimeout(r, 1000));

                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}&countrycodes=gb&limit=1`,
                    {
                        headers: {
                            'User-Agent': 'StorytellingEventsCalendar/1.0'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    const coords = { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
                    geocodeCache[location] = coords;
                    resolve(coords);
                } else {
                    console.warn(`No geocoding results for: ${location}`);
                    geocodeCache[location] = null;
                    resolve(null);
                }
            } catch (error) {
                console.error(`Geocoding error for "${location}":`, error.message);
                geocodeCache[location] = null;
                resolve(null);
            } finally {
                isGeocoding = false;
                // Process next item in queue
                if (geocodeQueue.length > 0) {
                    setTimeout(() => processGeocodeQueue(), 100);
                }
            }
        }

        function parseSchedule(schedule, startDate, endDate) {
            const results = [];
            if (schedule.includes('/')) {
                const [day, month, year] = schedule.split('/').map(num => parseInt(num, 10));
                const specificDate = new Date(year, month - 1, day);
                if (specificDate >= startDate && specificDate <= endDate) {
                    results.push(specificDate);
                }
                return results;
            }

            const [occurrence, dayName] = schedule.toLowerCase().split(/\s+/);
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const targetDay = dayMap[dayName];

            const current = new Date(startDate.getFullYear(), startDate.getMonth() - 1, 1);
            const extendedEnd = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);

            while (current <= extendedEnd) {
                const year = current.getFullYear();
                const month = current.getMonth();
                const lastDay = new Date(year, month + 1, 0);

                let eventDate = null;

                if (occurrence === 'last') {
                    for (let d = lastDay.getDate(); d >= 1; d--) {
                        const testDate = new Date(year, month, d);
                        if (testDate.getDay() === targetDay) {
                            eventDate = testDate;
                            break;
                        }
                    }
                } else {
                    const occurrenceNum = occurrence === '1st' ? 1 : occurrence === '2nd' ? 2 : occurrence === '3rd' ? 3 : 4;
                    let count = 0;
                    for (let d = 1; d <= lastDay.getDate(); d++) {
                        const testDate = new Date(year, month, d);
                        if (testDate.getDay() === targetDay) {
                            count++;
                            if (count === occurrenceNum) {
                                eventDate = testDate;
                                break;
                            }
                        }
                    }
                }

                if (eventDate && eventDate >= startDate && eventDate <= endDate) {
                    results.push(eventDate);
                }

                current.setMonth(current.getMonth() + 1);
            }

            return results;
        }

        async function displayEvents(startDate, endDate) {
            if (!eventsData) {
                console.error('Events data not loaded');
                return;
            }

            const eventsList = document.getElementById('eventsList');
            allEventsData = [];

            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];

            // Process recurring events
            for (const event of eventsData.events || []) {
                const dates = parseSchedule(event.schedule, startDate, endDate);
                for (const date of dates) {
                    const eventData = {
                        name: event.name,
                        date: date,
                        location: event.location,
                        club: event.club,
                        latlon: event.latlon || null,
                        isStoryclub: true,
                        isSpecial: false,
                        isMusic: false
                    };
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process specific events
            for (const event of eventsData.specificEvents || []) {
                if (!event.date) {
                    console.warn('Specific event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        location: event.location,
                        performer: event.performer,
                        latlon: event.latlon || null,
                        isStoryclub: false,
                        isSpecial: true,  // All specificEvents are special events
                        isMusic: false
                    };
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            // Process music events
            for (const event of eventsData.musicEvents || []) {
                if (!event.date) {
                    console.warn('Music event missing date:', event);
                    continue;
                }

                const dateParts = event.date.split('/');
                if (dateParts.length !== 3) {
                    console.warn('Invalid date format for music event:', event);
                    continue;
                }

                const day = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10);
                const year = parseInt(dateParts[2], 10);

                const eventDate = new Date(year, month - 1, day);
                if (eventDate >= startDate && eventDate <= endDate) {
                    const eventData = {
                        name: event.name,
                        date: eventDate,
                        location: event.location,
                        performer: event.performer,
                        latlon: event.latlon || null,
                        isStoryclub: false,
                        isSpecial: false,
                        isMusic: true  // All musicEvents are music
                    };
                    allEventsData.push(eventData);
                    await addMarkerForEvent(eventData);
                }
            }

            allEventsData.sort((a, b) => a.date - b.date);
            renderEventsList(allEventsData);
        }

        async function addMarkerForEvent(eventData) {
            // Check if latlon is provided directly
            let coords;
            if (eventData.latlon && Array.isArray(eventData.latlon) && eventData.latlon.length === 2) {
                coords = { lat: eventData.latlon[0], lon: eventData.latlon[1] };
            } else {
                // Fall back to geocoding
                coords = await geocodeLocation(eventData.location);
            }

            if (coords) {
                eventData.coords = coords;

                // Color coding: grey for story clubs, green for special events, blue for music
                const markerColor = eventData.isMusic ? '#443cd7' :
                    eventData.isSpecial ? '#4CAF50' :
                        '#808080'; // grey for regular story clubs

                const marker = L.circleMarker([coords.lat, coords.lon], {
                    radius: 8,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);

                const popupContent = `
                    <div class="popup-content">
                        <h3>${eventData.name}</h3>
                        <p><strong>${formatDate(eventData.date)}</strong></p>
                        <p>${eventData.location}</p>
                        ${eventData.performer ? `<p><em>${eventData.performer}</em></p>` : ''}
                    </div>
                `;

                marker.bindPopup(popupContent);
                marker.eventData = eventData;

                marker.on('click', () => {
                    highlightEvent(eventData);
                });

                markers.push(marker);
            }
        }

        function updateMapView() {
            // Don't filter by map bounds - show all events in the selected date range
            // The map bounds filtering was hiding events
            filterEvents();
        }

        function renderEventsList(eventsToShow) {
            const eventsList = document.getElementById('eventsList');
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            if (eventsToShow.length === 0) {
                eventsList.innerHTML = '<div class="no-events">No events in this view</div>';
                return;
            }

            console.log(`Rendering ${eventsToShow.length} events`);

            eventsList.innerHTML = eventsToShow.map(event => {
                const dayName = daysOfWeek[event.date.getDay()];
                const day = event.date.getDate();
                const month = months[event.date.getMonth()];
                const year = event.date.getFullYear();

                // Properly set CSS classes based on event type
                const storyclubClass = event.isStoryclub ? ' storyclub' : '';
                const specialClass = event.isSpecial ? ' special' : '';
                const musicClass = event.isMusic ? ' music' : '';

                console.log(`Event: ${event.name}, classes: storyclub=${event.isStoryclub}, special=${event.isSpecial}, music=${event.isMusic}`);

                return `
                    <div class="event${storyclubClass}${specialClass}${musicClass}" 
                         onclick="zoomToEvent(${event.coords?.lat}, ${event.coords?.lon})"
                         data-event-id="${event.name}-${event.date.getTime()}">
                        <div class="event-name">${event.name}</div>
                        ${event.performer ? `<div style="font-style: italic;">${event.performer}</div>` : ''}
                        <div class="event-location">${event.location}</div>
                        <div class="event-date">${dayName}, ${day} ${month} ${year}</div>
                    </div>
                `;
            }).join('');

            filterEvents();
        }

        function zoomToEvent(lat, lon) {
            if (lat && lon) {
                map.setView([lat, lon], 13);
            }
        }

        function highlightEvent(eventData) {
            const eventId = `${eventData.name}-${eventData.date.getTime()}`;
            document.querySelectorAll('.event').forEach(el => el.classList.remove('highlighted'));
            const eventEl = document.querySelector(`[data-event-id="${eventId}"]`);
            if (eventEl) {
                eventEl.classList.add('highlighted');
                eventEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function formatDate(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${days[date.getDay()]}, ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function filterEvents() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const specialOn = document.getElementById('specialOn').checked;
            const storyclubsOn = document.getElementById('storyclubsOn').checked;
            const showMusic = document.getElementById('showMusic').checked;

            console.log('Filter settings:', { specialOn, storyclubsOn, showMusic });

            const allEventElements = document.querySelectorAll('.event');
            console.log(`Total event elements: ${allEventElements.length}`);

            allEventElements.forEach(event => {
                let visible = false;

                const isStoryclub = event.classList.contains('storyclub');
                const isSpecial = event.classList.contains('special');
                const isMusic = event.classList.contains('music');

                console.log(`Event classes: storyclub=${isStoryclub}, special=${isSpecial}, music=${isMusic}`);

                // Show event if its type checkbox is checked
                if (storyclubsOn && isStoryclub) visible = true;
                if (specialOn && isSpecial) visible = true;
                if (showMusic && isMusic) visible = true;

                // Apply search filter if search term exists
                if (visible && searchTerm) {
                    const text = event.textContent.toLowerCase();
                    visible = text.includes(searchTerm);
                }

                event.classList.toggle('hidden', !visible);
            });

            // Count visible events
            const visibleCount = document.querySelectorAll('.event:not(.hidden)').length;
            console.log(`Visible events after filtering: ${visibleCount}`);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            filterEvents();
        }

        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function getWeekEnd(weekStart) {
            const end = new Date(weekStart);
            end.setDate(end.getDate() + 6);
            return end;
        }

        function setActiveMode(mode) {
            document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
            if (mode === 'thisWeek') document.getElementById('thisWeekBtn').classList.add('active');
            else if (mode === 'nextWeek1') document.getElementById('nextWeekBtn').classList.add('active');
            else if (mode === 'nextWeek2') document.getElementById('afterThatWeekBtn').classList.add('active');
            else if (mode === 'nextWeek3') document.getElementById('andAnotherWeekBtn').classList.add('active');
            else if (mode === 'lastWeek1') document.getElementById('lastWeekBtn').classList.add('active');
        }

        function showThisWeek() {
            const today = new Date();
            const weekStart = getWeekStart(today);
            const weekEnd = getWeekEnd(weekStart);
            displayEvents(weekStart, weekEnd);
            setActiveMode('thisWeek');
        }

        function showWeek(weeksAhead = 1) {
            const today = new Date();
            const thisWeekStart = getWeekStart(today);
            const targetWeekStart = new Date(thisWeekStart);
            targetWeekStart.setDate(targetWeekStart.getDate() + (7 * weeksAhead));
            const targetWeekEnd = getWeekEnd(targetWeekStart);
            displayEvents(targetWeekStart, targetWeekEnd);
            setActiveMode(weeksAhead > 0 ? `nextWeek${weeksAhead}` : `lastWeek${Math.abs(weeksAhead)}`);
        }

        function showDateRange() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;

            if (!startInput) {
                alert('Please select at least a start date');
                return;
            }

            const startDate = new Date(startInput);
            const endDate = endInput ? new Date(endInput) : getWeekEnd(getWeekStart(startDate));
            displayEvents(startDate, endDate);
        }

        function handleDateChange() {
            const startInput = document.getElementById('startDate').value;
            if (startInput) showDateRange();
        }

        // Initialize
        window.addEventListener('load', async () => {
            await loadEventsData();
            await loadExternalGeocodeCache();
            initMap();
            showThisWeek();
        });
    </script>
</body>

</html>